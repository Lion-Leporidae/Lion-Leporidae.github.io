<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="LionLpeoridae">





<title>数据结构 | LionLeporidae</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">LionLeporidae&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">LionLeporidae&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">数据结构</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">LionLpeoridae</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">January 6, 2025&nbsp;&nbsp;0:24:26</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>[TOC]</p>
<h2 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h2><p>构成数据元素的不可分割的<em><strong>最小单位</strong></em></p>
<p>一个数据元素可由若干个<em><strong>数据项</strong></em>组成</p>
<h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><p>数据的<em><strong>基本单位</strong></em></p>
<h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>具有相同性质的<em><strong>数据元素</strong></em>的集合</p>
<h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p>相互之间存在一种或多种特定关系的<em><strong>数据元素的集合</strong></em></p>
<p><em><strong>逻辑结构，存储结构，数据运算</strong></em></p>
<h2 id="二元组"><a href="#二元组" class="headerlink" title="二元组"></a>二元组</h2><p>D_S &#x3D; （d，s）D &#x3D; 数据集 ，S &#x3D; 数据关系</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>线性表 一对一</p>
<h3 id="非线性结构（一对多）"><a href="#非线性结构（一对多）" class="headerlink" title="非线性结构（一对多）"></a>非线性结构（一对多）</h3><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><h4 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h4><h4 id="图形结构或网状结构"><a href="#图形结构或网状结构" class="headerlink" title="图形结构或网状结构"></a>图形结构或网状结构</h4><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><ul>
<li><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><p>​	逻辑上相邻的元素存储在物理位置也相邻的存储单位</p>
</li>
<li><h3 id="链式"><a href="#链式" class="headerlink" title="链式"></a>链式</h3><p>​	借助指示元素存储地址的指针</p>
</li>
<li><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>​	索引表		索引项（关键字	地址）</p>
</li>
<li><h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><p>​	hash存储	关键字 ——-&gt;存储地址（通过散列函数）</p>
<p><em><strong>*根据元素的关键字直接计算出该元素的存储地址，又称哈希(hash)存储*</strong></em></p>
</li>
</ul>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol>
<li><p><strong>有穷性</strong></p>
</li>
<li><p><strong>确定性</strong></p>
</li>
<li><p><strong>可行性</strong></p>
</li>
<li><p><strong>输入</strong></p>
</li>
<li><p><strong>输出</strong></p>
</li>
</ol>
<ul>
<li>好的算法参考</li>
<li><strong>正确性</strong></li>
<li><strong>可读性</strong></li>
<li><strong>健壮性</strong></li>
<li><strong>效率与低存储量需求</strong></li>
</ul>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><img src="/image-20241226214140253.png" alt="image-20241226214140253"></p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>具有相同数据类型的n（n&gt;&#x3D;0）个<em><strong>数据元素</strong></em>的<em><strong>有限序列</strong></em></p>
<p>除<em><strong>第一个</strong></em>元素外，每个元素<em><strong>有且仅有一个</strong></em>直接<em><strong>前驱</strong></em></p>
<p>除<em><strong>最后一个</strong></em>元素外，每个元素<em><strong>有且仅有一个</strong></em>直接<em><strong>后继</strong></em></p>
<p><img src="/image-20241226214916083.png" alt="image-20241226214916083"></p>
<h2 id="顺序表-1"><a href="#顺序表-1" class="headerlink" title="顺序表"></a>顺序表</h2><p>顺序存储的线性表——-可以联想到<em><strong>数组</strong></em></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>顺序表最主要的特点是<em><strong>随机存取</strong></em>，即通过<em><strong>首地址和元素序号</strong></em>可在时间O(1）内找到指定元素</li>
<li>顺序表的<em><strong>存储密度</strong></em>高，每个结点<em><strong>只存储数据元素</strong></em></li>
<li>顺序表逻辑上<em><strong>相邻的元素物理上也相邻</strong></em>，所以插入和删除操作需要移动大量元素</li>
</ol>
<h3 id="顺序表实现"><a href="#顺序表实现" class="headerlink" title="顺序表实现"></a>顺序表实现</h3><p><strong>插入操作</strong></p>
<p>移动最多次数 n(n-1)&#x2F;2</p>
<p>移动结点的平均次数 (n-1)&#x2F;2<img src="/image-20241226223156915.png" alt="image-20241226223156915"></p>
<p><img src="/image-20241226224400812.png" alt="image-20241226224400812"></p>
<p><strong>按值查找</strong></p>
<p>在顺序表中查找第一个元素值等于e的元素返回其位序</p>
<p><strong>按位查找</strong></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>线性表与链表不能比较，各有各的优势</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>链式存储的线性表</p>
<p>增加一个头结点的目的是存储方便</p>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>双指针</p>
<p>分别指向前驱结点和后继结点</p>
<p>会头尾相连</p>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>只允许在一端进行插入或删除操作的线性表</p>
<p>空栈：不含任何元素的空表</p>
<p>特性： 先进后出</p>
<p>先移指针在在存值</p>
<p><img src="/image-20241227141653707.png" alt="image-20241227141653707"></p>
<p><img src="/image-20241227141901128.png" alt="image-20241227141901128"></p>
<p><img src="/image-20241227141935501.png" alt="image-20241227141935501"></p>
<p><img src="/image-20241227142611960.png" alt="image-20241227142611960"></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>只能允许在表的一端进行插入，而在表的的另一端进行删除</p>
<p>入队或进队</p>
<p>出队或离队</p>
<p>特性：先进先出</p>
<p><img src="/image-20241227142930412.png" alt="image-20241227142930412"></p>
<p>顺序存储会有不判满的情况</p>
<p><img src="/image-20241227143529143.png" alt="image-20241227143529143"></p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p><img src="/image-20241227143808262.png" alt="image-20241227143808262"></p>
<p><img src="/image-20241227153615132.png" alt="image-20241227153615132"></p>
<p><strong>循环队列中元素的个数有：<em>（rear + m - front) % m</em></strong></p>
<p><em><strong>m &#x3D; maxsize</strong></em> </p>
<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><p>有0个或多个字符组成的有限序列</p>
<p>子串：串中任意个<em><strong>连续的字符</strong></em>组成的子序列</p>
<p>字符在串中的位置：该字符在串中的序号</p>
<p>​				   子串在主串的位置以<em><strong>子串的第一个字符在主串中的位置</strong></em>来表示</p>
<p>当两个串的长度相等且每个对应未知的字符都相等时，称这两个串是相等的</p>
<p>空格串： 有<em><strong>一个或多个空格</strong></em>组成串</p>
<p><img src="/image-20241227174709503.png" alt="image-20241227174709503"></p>
<p><em><strong>模式匹配</strong></em>：子串的定位操作，它求的是子串在主串的位置</p>
<p>压缩存储：</p>
<ul>
<li>为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间</li>
<li>其目的是为了节省存储空间</li>
</ul>
<p>	</p>
<p>特殊矩阵：</p>
<ul>
<li>具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素分布有一定规律性的矩阵</li>
</ul>
<h2 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h2><p><img src="/image-20241227175347670.png" alt="image-20241227175347670"></p>
<p><img src="/image-20241227175836492.png" alt="image-20241227175836492"></p>
<p><img src="/image-20241227180035500.png" alt="image-20241227180035500"></p>
<p><img src="/image-20241227180144783.png" alt="image-20241227180144783"></p>
<p><img src="/image-20241227180221714.png" alt="image-20241227180221714"></p>
<p><img src="/image-20241227180239998.png" alt="image-20241227180239998"> </p>
<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>n个结点的有限集</p>
<h3 id="树的性质："><a href="#树的性质：" class="headerlink" title="树的性质："></a>树的性质：</h3><ul>
<li><p>树中的结点数等于所有结点的度数加1</p>
</li>
<li><p>度为m的树中第i层上至多有  $$ m ^ {i - 1}$$ 个结点</p>
</li>
<li><p>高度为<em><strong>h</strong></em>的<em><strong>m</strong></em>叉树至多有$$ (m ^{k} - 1)&#x2F;(m - 1)$$ </p>
<p>$$ 1 + m + m ^ 2 +m ^ 3 +…..+m ^ {k - 1}$$ </p>
</li>
<li><p>具有<em><strong>n</strong></em>个结点的<em><strong>m</strong></em>叉树的最小高度为$$ log_m(n(m - 1) +1)$$</p>
</li>
</ul>
<p><img src="/image-20241227203348318.png" alt="image-20241227203348318"></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul>
<li><p>空二叉树</p>
</li>
<li><p>由一个根节点和两个互不相交的被称为根的左子树和右子树组成</p>
</li>
<li><p>左右子树由分别是一颗二叉树</p>
<p>性质：</p>
<ul>
<li>非空二叉树上的叶子结点数等于度为2的结点数加1，即n0 &#x3D; n2 + 1</li>
<li>非空二叉树上第k层上至多有$$2^(k - 1)$$ 个结点</li>
<li>高度为h的二叉树至多有$$ 2 ^ k - 1$$ 个结点</li>
</ul>
</li>
</ul>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>深度为h，满$$ 2 ^ h - 1$$</p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>依次排序在左节点上</p>
<p>具有n个结点的完全二叉树的高度为$$ log_2 (n + 1) $$ 或者$$ log_2 (n) + 1 $$</p>
<p>h      $$ 2^ {h - 1} - 1 &lt; n \leq 2^h - 1  $$</p>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>树上任一结点的左子树和右子树的深度之差绝对值不超过1</p>
<p><img src="/image-20241227221754772.png" alt="image-20241227221754772"></p>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序-1"><a href="#顺序-1" class="headerlink" title="顺序"></a>顺序</h3><p>指用一组地址连续的存储单元依次<em><strong>自上而下，自左至右存储</strong></em>完全二叉树的节点元素，即将完全二叉树上编号为<em><strong>i</strong></em>的结点元素存储在一维数组下标<em><strong>i- 1</strong></em>的分量中</p>
<h3 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h3><p>用链表结点来存储二叉树中的每个结点</p>
<p><strong>链式存储</strong>：</p>
<p>在含有n个结点的二叉链表中，含有<em>n+ 1</em>个空链域，含有n - 1 个非空链域</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>按某条搜索路劲访问树中每个结点，使得每个结点均被访问一次而且仅被访问一次</p>
<p>按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序，中序，和后序三种</p>
<ul>
<li><p>先序</p>
<ul>
<li>若二叉树为空，则什么也不做，否则、</li>
<li>访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
<li><img src="/image-20241227230850054.png" alt="image-20241227230850054"></li>
</ul>
</li>
<li><p>中序</p>
<ul>
<li>若二叉树为空，则什么也不做，否则</li>
<li>中序遍历左子树</li>
<li>访问根结点</li>
<li>中序遍历右子树</li>
<li><img src="/image-20241227230915328.png" alt="image-20241227230915328"></li>
</ul>
</li>
<li><p>后序</p>
<ul>
<li>若二叉树为空，则什么也不做，否则</li>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根节点</li>
<li><img src="/image-20241227231016376.png" alt="image-20241227231016376"></li>
</ul>
</li>
<li><p>层次遍历</p>
<ul>
<li>依次入队然后出队遍历</li>
<li><img src="/image-20241227231156625.png" alt="image-20241227231156625"></li>
</ul>
</li>
</ul>
<h1 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h1><p>树的存储结构：双亲表示，孩子表示，孩子兄弟表示</p>
<ol>
<li><p>将树转换成二叉树</p>
<p><img src="/image-20241227231820761.png" alt="image-20241227231820761"></p>
</li>
</ol>
<p>由树转换成二叉树，其<em><strong>根结点的右子树总是空的</strong></em></p>
<h2 id="将森林转换成二叉树"><a href="#将森林转换成二叉树" class="headerlink" title="将森林转换成二叉树"></a>将森林转换成二叉树</h2><p><img src="/image-20241228154937923.png" alt="image-20241228154937923"></p>
<p><img src="/image-20241228155214057.png" alt="image-20241228155214057"></p>
<h2 id="二叉树对应的森林"><a href="#二叉树对应的森林" class="headerlink" title="二叉树对应的森林"></a>二叉树对应的森林</h2><p><img src="/image-20241228155341305.png" alt="image-20241228155341305"></p>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><ol>
<li><p>先根遍历   先根后子树</p>
</li>
<li><p>后根遍历   先子树后根</p>
<p><img src="/image-20241228155602076.png" alt="image-20241228155602076"></p>
</li>
</ol>
<h2 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h2><ul>
<li>先序遍历   先根后子树</li>
<li>中序遍历</li>
</ul>
<p><img src="/image-20241228155737794.png" alt="image-20241228155737794"></p>
<h2 id="二叉排序树-1"><a href="#二叉排序树-1" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><ol>
<li>若左子树非空，则左子树上的所有结点的值均小于根节点的值</li>
<li>若右子树非空，则右子树上的所有结点的值均大于根节点的值</li>
<li>左右子树也分别是一棵二叉排序树</li>
</ol>
<p> 若对一颗二叉排序树构成的序列采用<em><strong>中序遍历</strong></em>，可得<em><strong>升序</strong></em>的结果</p>
<h3 id="二叉排序树插入"><a href="#二叉排序树插入" class="headerlink" title="二叉排序树插入"></a>二叉排序树插入</h3><p>若原二叉排序树为空，则直接插入结点，否则若关键字小于根节点值，则插入到左子树，若关键字大于根节点值，则插入到右子树</p>
<p><img src="/image-20241228160604369.png" alt="image-20241228160604369"></p>
<h3 id="二叉排序树的构造"><a href="#二叉排序树的构造" class="headerlink" title="二叉排序树的构造"></a>二叉排序树的构造</h3><p>从一棵空树出发，依次输入元素，将他们插入二叉排序树的合适位置</p>
<h3 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h3><ol>
<li>若被删除的节点是<em><strong>叶子结点</strong></em>，则直接删除</li>
<li>若节点只有一颗左子树或者右子树，则让该结点的子树成为其父节点的子树</li>
<li>若结点有左右两棵子树，则令该结点的<em><strong>直接后继（直接前驱）</strong></em>{使用中序遍历来找}代替该节点，然后从二叉排序树中删去这个直接后继（直接前驱），这样就转换成了前两种情况</li>
</ol>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>带权路径长度（树的带权路径长度）<em><strong>最小</strong></em>的二叉树</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>权： 树中结点常被赋予一个代表某种意义的数值</li>
<li>结点带权路径长路：从树的根到任意结点的路径长度与该节点上权值的乘积</li>
<li>树的带权路劲长度：树中所有叶节点的带权路径长度之和，记为$$ WPL &#x3D; \sum_{i &#x3D; 1}^{n}w_il_i$$WPL——带权路劲长     w——权值   l——路径长</li>
</ul>
<h3 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h3><ol>
<li><p>将所有结点分别作为仅含一个结点的二叉树</p>
</li>
<li><p>构造一个新节点，从中选取两颗树节点权值最小的树作为新节点的左右子树，并且将新节点的权值作为左右子树上根节点的权值之和</p>
<p>个人理解：<em><strong>选出两个最小值形成一个二叉树然后相加将根节点放回列表中选，持续将表中的数全部清空为止，最顶根节点是最大的</strong></em></p>
</li>
<li><p>从中删除刚才选出的两颗树，同时将新得到的树加入森林中</p>
</li>
<li><p>直至剩下一颗树为止</p>
</li>
</ol>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>将右子树的标为1，左子树标为0</p>
<p><img src="/image-20241228165938214.png" alt="image-20241228165938214"></p>
<h3 id="哈夫曼编码电文（本博主觉得最抽象的东西）"><a href="#哈夫曼编码电文（本博主觉得最抽象的东西）" class="headerlink" title="哈夫曼编码电文（本博主觉得最抽象的东西）"></a>哈夫曼编码电文（本博主觉得最抽象的东西）</h3><p>直接上图吧</p>
<p><img src="/image-20241228170109867.png" alt="image-20241228170109867"></p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h2><ol>
<li><p>有向图</p>
</li>
<li><p>无向图</p>
</li>
<li><p>简单图</p>
</li>
<li><p>多重图</p>
</li>
<li><p>完全图<br>对于无向图，任意两个顶点之间都存在边 边数：$n(n - 1)&#x2F; 2$</p>
<p>对于有向图 任意两个顶点之间都存在方向相反的两条弧  边数：$n(n - 1)$</p>
</li>
<li><p>子图，生成子图</p>
</li>
<li><p>连通图</p>
<p>连通图：图中任意两个顶点都是连通的</p>
<p>极小连通图：既要保持图连通又要使得边数最小的子图</p>
</li>
<li><p>生成树：包含图中全部顶点的一个极小连通子图  边数：$ 顶点数 - 1$</p>
</li>
<li><p>顶点的度，入度和出度</p>
<ul>
<li><p>无向图的全部顶点的度的和等于边数的两倍</p>
</li>
<li><p>对于有向图，入度是以顶点v为终点的有向边的数目</p>
</li>
</ul>
<p>​			出度是以顶点v为起点的有向边的数目</p>
<ul>
<li><p>顶点的度等于入度和出度之和</p>
</li>
<li><p>有向图的全部顶点的入度之和与出度之和相等，并且等于边数</p>
</li>
</ul>
</li>
<li><p>边的权和网</p>
</li>
<li><p>路径，路径长度和回路</p>
</li>
</ol>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><p>邻接矩阵法，领接表法，十字链表法，领接多重表法</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>无向边图：</p>
<p>​	n个点的无向边图，则有2（n - 1）的非0元素，对于无向图来说最少边有n - 1条，在邻接矩阵中要算两次，所以*2</p>
<p>​	只接受邻近的</p>
<p>​	边存在为1，无边为0</p>
<p>有向边图：</p>
<p>​	只接受邻近的且通向外面的</p>
<p>​	有则为1，无则为0</p>
<p>带权图：</p>
<p>​	边存在则为权值，不存在要么为0，要么无穷</p>
<p><img src="/image-20241230192233554.png" alt="image-20241230192233554"></p>
<p>用邻接矩阵储存一个图时，在不考虑压缩存储的情况下，所占用的存储空间大小只与<em><strong>图中顶点的个数</strong></em>有关，而与<em><strong>图的边数</strong></em>无关</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>顶点域 +边表头指针</p>
<p>邻接点域 + 指针域</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>若g为无向图，则所需的存储空间为$O（|V| + 2|E|)$</p>
<p>若为有向图，则所需的存储空间为$O（|V| + |E|）$</p>
<p><em><strong>V  &#x3D;&#x3D; 结点    E &#x3D;&#x3D; 边</strong></em></p>
<p>对于稀疏图，采用邻接表表示能极大地节省存储空间</p>
<p>图的邻接表表示不唯一</p>
<p>在有向图的邻接表表示中，求一个给定顶点的出度只需计算其邻接表中的节点个数</p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>从图中的某个顶点出发，按照某种搜索方法沿着图中的所有顶点访问一次且仅访问一次</p>
<p>方法有两种：<em><strong>广度优先搜索和深度优先搜索</strong></em></p>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>类似二叉树的层序遍历算法</p>
<p>利用到队列来实现</p>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>类似树的先序遍历，</p>
<p>使用到栈来实现</p>
<p>用深度优先访问可能不会将所有的点进行遍历到</p>
<p>只有连通图才能访问到所有的点</p>
<p>所以如果一个<em><strong>无向图</strong></em>的任意顶点出发进行<em><strong>一次深度优先搜索即可访问所有顶点</strong></em>，则该图一定是<em><strong>连通图</strong></em></p>
<h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p> 带权连通无向图中，所有生成树中的权值之和最小的生成树</p>
<h3 id="prim算法："><a href="#prim算法：" class="headerlink" title="prim算法："></a>prim算法：</h3><p>任取一顶点，去掉所有边</p>
<p>选择一个当前顶点集合<em><strong>距离（权值最低的）最近</strong></em>的顶点，并将该顶点和相应的边加入进来，同时不能形成<em><strong>回路</strong></em></p>
<p>重复步骤，直至图中所有顶点都并入</p>
<p><img src="/image-20241231205224496.png" alt="image-20241231205224496"></p>
<h3 id="Kruskal算法："><a href="#Kruskal算法：" class="headerlink" title="Kruskal算法："></a>Kruskal算法：</h3><p>去掉所有边</p>
<p>选边（权最小且不成回路）</p>
<p>重复</p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>两个集合</p>
<p>一个没有选到结点的集合</p>
<p>一个选到了的结点的集合</p>
<h3 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h3><p>$d(u,u) &#x3D; 0$</p>
<p>当$u$和$v$不相邻时，$d(u,v) &#x3D; +\infty$</p>
<p><img src="/image-20241231210728772.png" alt="image-20241231210728772"></p>
<p> <img src="/image-20241231210912606.png" alt="image-20241231210912606"></p>
<p><img src="/image-20241231210921077.png" alt="image-20241231210921077"></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>AOV网：顶点表示活动$&lt;Vi,Vj&gt;$</p>
<p>每个顶点出现且只出现一次</p>
<p>若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面</p>
<h3 id="拓扑排序的算法的步骤："><a href="#拓扑排序的算法的步骤：" class="headerlink" title="拓扑排序的算法的步骤："></a>拓扑排序的算法的步骤：</h3><p>从AOV网中选择一个没有前驱的顶点并输出</p>
<p>从网中删除该顶点和所有以它为起点的有向边</p>
<p>直到AOV网为空或者当前网中不存在无前驱的顶点为止</p>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>AOV网：以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销</p>
<p>关键路径：从<em><strong>开始顶点到结束顶点的所有路径</strong></em>中，具有<em><strong>最大路径长度的路径</strong></em>，即从源点到汇点的最长路径</p>
<p>关键活动：关键路径上的活动</p>
<h3 id="事件-vk-的最早发生时间-ve-k"><a href="#事件-vk-的最早发生时间-ve-k" class="headerlink" title="事件$vk$的最早发生时间$ve(k)$"></a>事件$vk$的最早发生时间$ve(k)$</h3><p>指从源点$v_1$到顶点$v_k$的<em><strong>最长路径长度</strong></em></p>
<p>$v_e$ &#x3D; 0 （源点）</p>
<p>$v_e(k) &#x3D; Max({ve(j) + Weight(v_j,v_k)})$</p>
<p>weight &#x3D;&#x3D; 权值</p>
<p>从前往后</p>
<p><img src="/image-20250101201843601.png" alt="image-20250101201843601"></p>
<p>例如：1 -&gt; 2  &#x3D;&#x3D; 12</p>
<h3 id="事件-v-k-的最迟发生时间-v-l-k"><a href="#事件-v-k-的最迟发生时间-v-l-k" class="headerlink" title="事件$v_k$的最迟发生时间$v_l(k)$"></a>事件$v_k$的最迟发生时间$v_l(k)$</h3><p>指在不推迟整个工程完成的前提下，既保证它的后续事件$v_j$在其最迟发生事件$v_l(j)$能够发生时，该事件最迟必须发生的时间</p>
<p>$v_l   &#x3D;   ve$</p>
<p>汇点  汇点</p>
<p>$v_l(k) &#x3D; Min(v_l(j) - Weight(v_k,v_j))$</p>
<p>从后往前</p>
<h3 id="活动-a-i-的最早开始时间-e-i"><a href="#活动-a-i-的最早开始时间-e-i" class="headerlink" title="活动$a_i$的最早开始时间$e(i)$"></a>活动$a_i$的最早开始时间$e(i)$</h3><p>指该活动弧的起点所表示的事件的最早发生时间</p>
<p>例如$&lt;v_k,v_j&gt;$有向边，从$v_k到v_j$这个为a活动，这个活动a的最早开始时间就是事件的最早发生时间</p>
<h3 id="活动-a-i-的最迟开始时间l-i"><a href="#活动-a-i-的最迟开始时间l-i" class="headerlink" title="活动$a_i$的最迟开始时间l(i)"></a>活动$a_i$的最迟开始时间l(i)</h3><p>指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差</p>
<p>例如$&lt;v_k,v_j&gt;$有向边，从$v_k到v_j$这个为a活动，$l(i) &#x3D; vl(j) - Weight(v_k,v_j)$</p>
<p>Weight 为权值 </p>
<h3 id="关键活动"><a href="#关键活动" class="headerlink" title="关键活动"></a>关键活动</h3><p>一个活动的最迟开始时间和其最早开始时间的差额</p>
<p>如果差值为0，则这个活动为关键活动</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li><p>令 源点 &#x3D; 0 ，求最早发生时间ve(）</p>
</li>
<li><p>令 $vl(汇点) &#x3D; ve(汇点)$,求最迟发生时间$vl()$</p>
</li>
<li><p>根据$ve()$值求所有弧的最早开始时间 e ()</p>
</li>
<li><p>根据$vl()$值求所有弧的最迟开始时间 l ()</p>
</li>
<li><p>求AOE网中所有活动的差额d(),找出所有d()  &#x3D; 0的活动构成关键路径</p>
<p><img src="/image-20250101220345751.png" alt="image-20250101220345751"></p>
</li>
</ol>
<p><img src="/image-20250101220331399.png" alt="image-20250101220331399"></p>
<p>关键路径 v1,v3,v4,v6</p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><ol>
<li>查找：在数据集合中，寻找满足某种条件的数据元素的过程</li>
<li>查找表：用于查找的数据集合</li>
<li>关键字：数据元素中某个数据项的值，用它可以标识一个数据元素</li>
<li>主关键字： 关键字可以唯一地标识一个记录</li>
<li>平均查找长度：所有查找过程中进行关键字的比较次数的平均值$ASL &#x3D; \sum_{i &#x3D; 1}^nP_iC_i$</li>
</ol>
<p>$p_i$就是查找第i个元素的概率</p>
<p>$c_i$是找到第i个元素的查找次数</p>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>从线性表的一端开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置。若查找到表的另一端，仍未找到符合给定条件的元素，则返回查找失败的信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType *elem; <span class="comment">//查找表的数据结构</span></span><br><span class="line">    <span class="type">int</span> TableLen;	<span class="comment">//元素存储空间基址，建表时按实际长度 </span></span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">&#125;SSTable;<span class="comment">//分配，0号元素留空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,ElemType key)</span></span>&#123;</span><br><span class="line">ST.elem[<span class="number">0</span>]=key;               <span class="comment">//“哨兵”</span></span><br><span class="line"><span class="keyword">for</span>(i=ST.TableLen;ST.elem[i]!=key;--i);</span><br><span class="line">	<span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>线性链表只能进行顺序查找</strong></em></p>
<p>对于n个元素的表，给定值key与表中第i个元素相等，需进行n-i+1次关键字的比较，查找成功时，顺序查找的平均查找长度为 (n + 1) &#x2F; 2</p>
<p>顺序查找的平均查找长度为$ASL_{不成功}$ &#x3D; n + 1</p>
<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>仅适用于<em><strong>有序的顺序表。</strong></em></p>
<p>首先将给定值与表中中间位置的元素比较，若相等，则查找成 功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分 或后半部分。然后在缩小的范围内继续进行同样的查找，如此反复，直至找到为止，或确 定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>   <span class="title">Binary_Search</span><span class="params">(SeqList   L,ElemType   key)</span></span>&#123; </span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>,high=L.TableLen<span class="number">-1</span>,mid;</span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">	mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(L.elem[mid]==key) <span class="keyword">return</span> mid;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key) high=mid<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		low=mid<span class="number">+1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在等概率查找时，查找成功的平均查找长度为<img src="/./image-20250105182311468.png" alt="image-20250105182311468"></p>
<p>$h &#x3D; log_2(n + 1)$</p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列函数：Hash（key） &#x3D; addr</p>
<p>同义词：散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这些情况为冲突，这些发生碰撞的不同关键字称为同义词。</p>
<h3 id="直接定位"><a href="#直接定位" class="headerlink" title="直接定位"></a>直接定位</h3><p>直接定址法：直接取关键字的某个线性函数值为散列地址，散列函数为 </p>
<p>H(key)&#x3D;key  或H(key)&#x3D;a×key+b(a,b是常数)</p>
<h3 id="除留余数"><a href="#除留余数" class="headerlink" title="除留余数"></a>除留余数</h3><p>假定散列表表长为m </p>
<p>取一个不大于m 但最接近或等于m 的质数p, </p>
<p>用key取模</p>
<h3 id="数字分析"><a href="#数字分析" class="headerlink" title="数字分析"></a>数字分析</h3><h3 id="平方取中"><a href="#平方取中" class="headerlink" title="平方取中"></a>平方取中</h3><h3 id="解决冲突的方法"><a href="#解决冲突的方法" class="headerlink" title="解决冲突的方法"></a>解决冲突的方法</h3><h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><p>可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义 词表项开放。其数学递推公式为H₁&#x3D;(H(key)+d)%m(H(key)            </p>
<p>为散 列函数，m 表示散列表表长，d,为增量序列。</p>
<p>对增量序列通常有以下取法：</p>
<ul>
<li>线性探测法。当d,&#x3D;0,1,2,…,m-1时，称为线性探测法。这种方法的特点是： 冲突发生时，顺序查看表中下一个单元(探测到表尾地址m-1时，下一个探测 地址就是表首地址0),直到找出一个空闲单元或查遍全表。</li>
<li>平方探测法。当d,&#x3D;0²,1²,-1²,2²,-2², … ,k²,-k² 时，称为平方探测法，其中k≤m&#x2F;2。</li>
<li>再散列法。当d,&#x3D;Hash₂(key)     时，称为再散列法。</li>
</ul>
<p>查找成功的平均查找长度ASL成功&#x3D;查找次数&#x2F;元素个数，这里的查找次数是比较次数</p>
<p>查找不成功的平均查找长度为ASL不咸功&#x3D;查找次数&#x2F;散列后的地址个数，这里的查找次数则是</p>
<p><img src="/image-20250105210643126.png" alt="image-20250105210643126"></p>
<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>为了避免非同义词发生冲突，把所有的同义词存储在一个线性链表中</p>
<p>在哈希表中，不成功的平均查找长度取决于<strong>装载因子</strong> $\alpha &#x3D; \frac{n}{m}$，其中 $n$ 是存储的关键字数，$m$ 是哈希表的槽位数。 </p>
<h3 id="a-开放地址法（Open-Addressing）"><a href="#a-开放地址法（Open-Addressing）" class="headerlink" title="(a) 开放地址法（Open Addressing）"></a>(a) 开放地址法（Open Addressing）</h3><p>$ASL_{\text{unsuccessful}} &#x3D; \frac{1}{1 - \alpha}$</p>
<h3 id="b-链地址法（Chaining）"><a href="#b-链地址法（Chaining）" class="headerlink" title="(b) 链地址法（Chaining）"></a>(b) 链地址法（Chaining）</h3><p>$ASL_{\text{unsuccessful}} &#x3D; \alpha$</p>
<h1 id="交换排序（Exchange-Sort）"><a href="#交换排序（Exchange-Sort）" class="headerlink" title="交换排序（Exchange Sort）"></a>交换排序（Exchange Sort）</h1><p>交换排序（Exchange Sort）是一种简单直观的排序算法，其基本思想是通过比较和交换数组中的元素，将无序的数组转变为有序的数组。交换排序的典型代表是冒泡排序（Bubble Sort）和选择排序（Selection Sort）。在本例中，我们将介绍一种基本的交换排序方法，即<strong>基本交换排序</strong>，它通过比较数组中所有可能的元素对，并在必要时交换它们的位置来实现排序。</p>
<h1 id="排序代码"><a href="#排序代码" class="headerlink" title="排序代码"></a>排序代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapElements</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本交换排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exchangeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 遍历每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 与后续每一个元素进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                <span class="built_in">swapElements</span>(arr[i], arr[j]);</span><br><span class="line">                <span class="comment">// 输出当前交换的元素及数组状态</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;交换元素 &quot;</span> &lt;&lt; arr[j] &lt;&lt; <span class="string">&quot; 和 &quot;</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; 后的数组: &quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">64</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n排序过程:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exchangeSort</span>(data);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><ol>
<li><strong>交换函数 (<code>swapElements</code>)：</strong><ul>
<li>接受两个整数引用作为参数，并交换它们的值。</li>
<li>使用临时变量 <code>temp</code> 来暂存一个值，完成交换。</li>
</ul>
</li>
<li><strong>基本交换排序函数 (<code>exchangeSort</code>)：</strong><ul>
<li>获取数组的大小 <code>n</code>。</li>
<li>外层循环遍历数组的每一个元素（从 <code>0</code> 到 <code>n-2</code>）。</li>
<li>内层循环与外层元素后面的每一个元素进行比较（从 <code>i+1</code> 到 <code>n-1</code>）。</li>
<li>如果发现前一个元素大于后一个元素，则调用 <code>swapElements</code> 进行交换，并输出交换后的数组状态。</li>
</ul>
</li>
<li><strong><code>main</code> 函数：</strong><ul>
<li>初始化一个整数数组 <code>data</code>。</li>
<li>输出原始数组。</li>
<li>调用 <code>exchangeSort</code> 函数进行排序，并输出排序过程中的每一次交换。</li>
<li>最后输出排序后的数组。</li>
</ul>
</li>
</ol>
<h2 id="排序流程"><a href="#排序流程" class="headerlink" title="排序流程"></a>排序流程</h2><p>假设我们有以下数组需要排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 64 25 12 22 11</span><br></pre></td></tr></table></figure>

<h3 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h3><p><strong>外层循环 <code>i = 0</code>：</strong></p>
<ul>
<li><p><strong>比较 <code>arr[0]</code> 和 <code>arr[1]</code>（64 和 25）：</strong></p>
<ul>
<li><p>64 &gt; 25，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 64 12 22 11</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 25 和 64 后的数组: 25 64 12 22 11 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[0]</code> 和 <code>arr[2]</code>（25 和 12）：</strong></p>
<ul>
<li><p>25 &gt; 12，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">0</span>], arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 64 25 22 11</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 12 和 25 后的数组: 12 64 25 22 11 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[0]</code> 和 <code>arr[3]</code>（12 和 22）：</strong></p>
<ul>
<li><p>12 &lt; 22，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 64 25 22 11</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[0]</code> 和 <code>arr[4]</code>（12 和 11）：</strong></p>
<ul>
<li><p>12 &gt; 11，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">0</span>], arr[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 64 25 22 12</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 11 和 12 后的数组: 11 64 25 22 12 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>外层循环 <code>i = 1</code>：</strong></p>
<ul>
<li><p><strong>比较 <code>arr[1]</code> 和 <code>arr[2]</code>（64 和 25）：</strong></p>
<ul>
<li><p>64 &gt; 25，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">1</span>], arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 25 64 22 12</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 25 和 64 后的数组: 11 25 64 22 12 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[1]</code> 和 <code>arr[3]</code>（25 和 22）：</strong></p>
<ul>
<li><p>25 &gt; 22，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">1</span>], arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 22 64 25 12</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 22 和 25 后的数组: 11 22 64 25 12 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[1]</code> 和 <code>arr[4]</code>（22 和 12）：</strong></p>
<ul>
<li><p>22 &gt; 12，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">1</span>], arr[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 64 25 22</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 12 和 22 后的数组: 11 12 64 25 22 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>外层循环 <code>i = 2</code>：</strong></p>
<ul>
<li><p><strong>比较 <code>arr[2]</code> 和 <code>arr[3]</code>（64 和 25）：</strong></p>
<ul>
<li><p>64 &gt; 25，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">2</span>], arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 25 64 22</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 25 和 64 后的数组: 11 12 25 64 22 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[2]</code> 和 <code>arr[4]</code>（25 和 22）：</strong></p>
<ul>
<li><p>25 &gt; 22，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">2</span>], arr[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 64 25</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 22 和 25 后的数组: 11 12 22 64 25 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>外层循环 <code>i = 3</code>：</strong></p>
<ul>
<li><p>比较 <code>arr[3]</code> 和 <code>arr[4]</code>（64 和 25）：</p>
<ul>
<li><p>64 &gt; 25，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">3</span>], arr[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 25 64</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 25 和 64 后的数组: 11 12 22 25 64 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>外层循环 <code>i = 4</code>：</strong></p>
<ul>
<li>不需要进行任何比较，因为 <code>j</code> 从 <code>i+1 = 5</code> 开始，超过数组范围。</li>
</ul>
<h3 id="排序过程总结"><a href="#排序过程总结" class="headerlink" title="排序过程总结"></a>排序过程总结</h3><p>整个排序过程中的每一次交换及数组状态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 64 25 12 22 11 </span><br><span class="line">排序过程:</span><br><span class="line">交换元素 25 和 64 后的数组: 25 64 12 22 11 </span><br><span class="line">交换元素 12 和 25 后的数组: 12 64 25 22 11 </span><br><span class="line">交换元素 11 和 12 后的数组: 11 64 25 22 12 </span><br><span class="line">交换元素 25 和 64 后的数组: 11 25 64 22 12 </span><br><span class="line">交换元素 22 和 25 后的数组: 11 22 64 25 12 </span><br><span class="line">交换元素 12 和 22 后的数组: 11 12 64 25 22 </span><br><span class="line">交换元素 25 和 64 后的数组: 11 12 25 64 22 </span><br><span class="line">交换元素 22 和 25 后的数组: 11 12 22 64 25 </span><br><span class="line">交换元素 25 和 64 后的数组: 11 12 22 25 64 </span><br><span class="line">排序后数组: 11 12 22 25 64 </span><br></pre></td></tr></table></figure>

<h2 id="最终排序结果"><a href="#最终排序结果" class="headerlink" title="最终排序结果"></a>最终排序结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排序后数组: 11 12 22 25 64</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>交换排序通过比较数组中所有可能的元素对，并在发现逆序时进行交换，逐步将数组变为有序状态。虽然其实现简单，但由于需要进行大量的比较和交换操作，其时间复杂度为O(n²)，在处理大规模数据时效率较低。交换排序适用于小规模数据的排序，或作为其他更复杂排序算法的基础。通过上述示例，可以清晰地理解交换排序的工作机制及其逐步排序的过程。</p>
<h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。其基本思想是通过多次比较和交换相邻元素，将最大的元素逐步“冒泡”到数组的末端。由于其实现简单，适用于小规模数据的排序，但在处理大规模数据时效率较低。</p>
<h2 id="排序代码-1"><a href="#排序代码-1" class="headerlink" title="排序代码"></a>排序代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">bool</span> swapped;</span><br><span class="line">    <span class="comment">// 外层循环控制所有的遍历轮数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 内层循环进行相邻元素的比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 输出当前交换的元素及数组状态</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;交换元素 &quot;</span> &lt;&lt; arr[j] &lt;&lt; <span class="string">&quot; 和 &quot;</span> &lt;&lt; arr[j + <span class="number">1</span>] &lt;&lt; <span class="string">&quot; 后的数组: &quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果在某一轮中没有发生交换，说明数组已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;第 &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; 轮没有发生交换，数组已经有序。&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n排序过程:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">bubbleSort</span>(data);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码说明-1"><a href="#代码说明-1" class="headerlink" title="代码说明"></a>代码说明</h2><ol>
<li><strong>包含头文件和命名空间：</strong><ul>
<li><code>#include &lt;iostream&gt;</code> 和 <code>#include &lt;vector&gt;</code>：用于输入输出和使用向量容器。</li>
<li><code>using namespace std;</code>：简化标准库的使用。</li>
</ul>
</li>
<li><strong>冒泡排序函数 (<code>bubbleSort</code>)：</strong><ul>
<li><strong>参数：</strong> 接受一个整数向量的引用 <code>arr</code>。</li>
<li>变量：<ul>
<li><code>n</code>：数组的大小。</li>
<li><code>swapped</code>：标记本轮是否发生交换，用于优化排序过程。</li>
</ul>
</li>
<li><strong>外层循环 (<code>for (int i = 0; i &lt; n - 1; i++)</code>)：</strong> 控制总共进行 <code>n-1</code> 轮排序。</li>
<li><strong>内层循环 (<code>for (int j = 0; j &lt; n - 1 - i; j++)</code>)：</strong> 每一轮中，将最大的元素“冒泡”到当前未排序部分的末端。</li>
<li><strong>交换条件：</strong> 如果当前元素 <code>arr[j]</code> 大于下一个元素 <code>arr[j + 1]</code>，则交换它们的位置，并将 <code>swapped</code> 标记为 <code>true</code>。</li>
<li><strong>优化：</strong> 如果在某一轮中没有发生任何交换，说明数组已经有序，可以提前终止排序。</li>
</ul>
</li>
<li><strong>主函数 (<code>main</code>)：</strong><ul>
<li><strong>初始化数组：</strong> <code>vector&lt;int&gt; data = &#123;64, 34, 25, 12, 22, 11, 90&#125;;</code></li>
<li><strong>输出原始数组。</strong></li>
<li><strong>调用 <code>bubbleSort</code> 函数进行排序，并输出排序过程中的每一次交换。</strong></li>
<li><strong>输出排序后的数组。</strong></li>
</ul>
</li>
</ol>
<h2 id="排序流程-1"><a href="#排序流程-1" class="headerlink" title="排序流程"></a>排序流程</h2><p>假设我们有以下数组需要排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 64 34 25 12 22 11 90</span><br></pre></td></tr></table></figure>

<h3 id="步骤详解-1"><a href="#步骤详解-1" class="headerlink" title="步骤详解"></a>步骤详解</h3><p><strong>外层循环 <code>i = 0</code>（第1轮）：</strong></p>
<ul>
<li><p><strong>比较 <code>arr[0]</code> 和 <code>arr[1]</code>（64 和 34）：</strong></p>
<ul>
<li><p>64 &gt; 34，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34 64 25 12 22 11 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 34 和 64 后的数组: 34 64 25 12 22 11 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[1]</code> 和 <code>arr[2]</code>（64 和 25）：</strong></p>
<ul>
<li><p>64 &gt; 25，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">1</span>], arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34 25 64 12 22 11 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 25 和 64 后的数组: 34 25 64 12 22 11 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[2]</code> 和 <code>arr[3]</code>（64 和 12）：</strong></p>
<ul>
<li><p>64 &gt; 12，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">2</span>], arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34 25 12 64 22 11 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 12 和 64 后的数组: 34 25 12 64 22 11 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[3]</code> 和 <code>arr[4]</code>（64 和 22）：</strong></p>
<ul>
<li><p>64 &gt; 22，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">3</span>], arr[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34 25 12 22 64 11 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 22 和 64 后的数组: 34 25 12 22 64 11 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[4]</code> 和 <code>arr[5]</code>（64 和 11）：</strong></p>
<ul>
<li><p>64 &gt; 11，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">4</span>], arr[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34 25 12 22 11 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 11 和 64 后的数组: 34 25 12 22 11 64 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[5]</code> 和 <code>arr[6]</code>（64 和 90）：</strong></p>
<ul>
<li><p>64 &lt; 90，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34 25 12 22 11 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>第1轮结束，最大的元素 90 已经在末端。</strong></p>
</li>
</ul>
<p><strong>外层循环 <code>i = 1</code>（第2轮）：</strong></p>
<ul>
<li><p><strong>比较 <code>arr[0]</code> 和 <code>arr[1]</code>（34 和 25）：</strong></p>
<ul>
<li><p>34 &gt; 25，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 34 12 22 11 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 25 和 34 后的数组: 25 34 12 22 11 64 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[1]</code> 和 <code>arr[2]</code>（34 和 12）：</strong></p>
<ul>
<li><p>34 &gt; 12，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">1</span>], arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 12 34 22 11 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 12 和 34 后的数组: 25 12 34 22 11 64 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[2]</code> 和 <code>arr[3]</code>（34 和 22）：</strong></p>
<ul>
<li><p>34 &gt; 22，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">2</span>], arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 12 22 34 11 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 22 和 34 后的数组: 25 12 22 34 11 64 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[3]</code> 和 <code>arr[4]</code>（34 和 11）：</strong></p>
<ul>
<li><p>34 &gt; 11，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">3</span>], arr[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 12 22 11 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 11 和 34 后的数组: 25 12 22 11 34 64 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[4]</code> 和 <code>arr[5]</code>（34 和 64）：</strong></p>
<ul>
<li><p>34 &lt; 64，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 12 22 11 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[5]</code> 和 <code>arr[6]</code>（64 和 90）：</strong></p>
<ul>
<li><p>64 &lt; 90，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 12 22 11 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>第2轮结束，第二大的元素 64 已经在倒数第二的位置。</strong></p>
</li>
</ul>
<p><strong>外层循环 <code>i = 2</code>（第3轮）：</strong></p>
<ul>
<li><p><strong>比较 <code>arr[0]</code> 和 <code>arr[1]</code>（25 和 12）：</strong></p>
<ul>
<li><p>25 &gt; 12，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 25 22 11 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 12 和 25 后的数组: 12 25 22 11 34 64 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[1]</code> 和 <code>arr[2]</code>（25 和 22）：</strong></p>
<ul>
<li><p>25 &gt; 22，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">1</span>], arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 22 25 11 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 22 和 25 后的数组: 12 22 25 11 34 64 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[2]</code> 和 <code>arr[3]</code>（25 和 11）：</strong></p>
<ul>
<li><p>25 &gt; 11，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">2</span>], arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 22 11 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 11 和 25 后的数组: 12 22 11 25 34 64 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[3]</code> 和 <code>arr[4]</code>（25 和 34）：</strong></p>
<ul>
<li><p>25 &lt; 34，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 22 11 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[4]</code> 和 <code>arr[5]</code>（34 和 64）：</strong></p>
<ul>
<li><p>34 &lt; 64，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 22 11 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[5]</code> 和 <code>arr[6]</code>（64 和 90）：</strong></p>
<ul>
<li><p>64 &lt; 90，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 22 11 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>第3轮结束，第三大的元素 34 已经在正确的位置。</strong></p>
</li>
</ul>
<p><strong>外层循环 <code>i = 3</code>（第4轮）：</strong></p>
<ul>
<li><p><strong>比较 <code>arr[0]</code> 和 <code>arr[1]</code>（12 和 22）：</strong></p>
<ul>
<li><p>12 &lt; 22，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 22 11 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[1]</code> 和 <code>arr[2]</code>（22 和 11）：</strong></p>
<ul>
<li><p>22 &gt; 11，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">1</span>], arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 11 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 11 和 22 后的数组: 12 11 22 25 34 64 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[2]</code> 和 <code>arr[3]</code>（22 和 25）：</strong></p>
<ul>
<li><p>22 &lt; 25，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 11 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[3]</code> 和 <code>arr[4]</code>（25 和 34）：</strong></p>
<ul>
<li><p>25 &lt; 34，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 11 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[4]</code> 和 <code>arr[5]</code>（34 和 64）：</strong></p>
<ul>
<li><p>34 &lt; 64，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 11 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[5]</code> 和 <code>arr[6]</code>（64 和 90）：</strong></p>
<ul>
<li><p>64 &lt; 90，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 11 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>第4轮结束，发现本轮发生了交换，继续下一轮。</strong></p>
</li>
</ul>
<p><strong>外层循环 <code>i = 4</code>（第5轮）：</strong></p>
<ul>
<li><p><strong>比较 <code>arr[0]</code> 和 <code>arr[1]</code>（12 和 11）：</strong></p>
<ul>
<li><p>12 &gt; 11，交换。</p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 11 和 12 后的数组: 11 12 22 25 34 64 90 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>比较 <code>arr[1]</code> 和 <code>arr[2]</code>（12 和 22）：</strong></p>
<ul>
<li><p>12 &lt; 22，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[2]</code> 和 <code>arr[3]</code>（22 和 25）：</strong></p>
<ul>
<li><p>22 &lt; 25，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[3]</code> 和 <code>arr[4]</code>（25 和 34）：</strong></p>
<ul>
<li><p>25 &lt; 34，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[4]</code> 和 <code>arr[5]</code>（34 和 64）：</strong></p>
<ul>
<li><p>34 &lt; 64，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[5]</code> 和 <code>arr[6]</code>（64 和 90）：</strong></p>
<ul>
<li><p>64 &lt; 90，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>第5轮结束，发现本轮发生了交换。</strong></p>
</li>
</ul>
<p><strong>外层循环 <code>i = 5</code>（第6轮）：</strong></p>
<ul>
<li><p><strong>比较 <code>arr[0]</code> 和 <code>arr[1]</code>（11 和 12）：</strong></p>
<ul>
<li><p>11 &lt; 12，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[1]</code> 和 <code>arr[2]</code>（12 和 22）：</strong></p>
<ul>
<li><p>12 &lt; 22，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[2]</code> 和 <code>arr[3]</code>（22 和 25）：</strong></p>
<ul>
<li><p>22 &lt; 25，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[3]</code> 和 <code>arr[4]</code>（25 和 34）：</strong></p>
<ul>
<li><p>25 &lt; 34，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[4]</code> 和 <code>arr[5]</code>（34 和 64）：</strong></p>
<ul>
<li><p>34 &lt; 64，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>比较 <code>arr[5]</code> 和 <code>arr[6]</code>（64 和 90）：</strong></p>
<ul>
<li><p>64 &lt; 90，不交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 22 25 34 64 90</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输出：</strong> 无变化</p>
</li>
</ul>
</li>
<li><p><strong>第6轮结束，未发生任何交换，说明数组已经有序，提前终止排序。</strong></p>
</li>
</ul>
<h3 id="排序过程总结-1"><a href="#排序过程总结-1" class="headerlink" title="排序过程总结"></a>排序过程总结</h3><p>整个排序过程中的每一次交换及数组状态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 64 34 25 12 22 11 90 </span><br><span class="line">排序过程:</span><br><span class="line">交换元素 34 和 64 后的数组: 34 64 25 12 22 11 90 </span><br><span class="line">交换元素 25 和 64 后的数组: 34 25 64 12 22 11 90 </span><br><span class="line">交换元素 12 和 64 后的数组: 34 25 12 64 22 11 90 </span><br><span class="line">交换元素 22 和 64 后的数组: 34 25 12 22 64 11 90 </span><br><span class="line">交换元素 11 和 64 后的数组: 34 25 12 22 11 64 90 </span><br><span class="line">交换元素 25 和 34 后的数组: 25 34 12 22 11 64 90 </span><br><span class="line">交换元素 12 和 34 后的数组: 25 12 34 22 11 64 90 </span><br><span class="line">交换元素 22 和 34 后的数组: 25 12 22 34 11 64 90 </span><br><span class="line">交换元素 11 和 34 后的数组: 25 12 22 11 34 64 90 </span><br><span class="line">交换元素 12 和 25 后的数组: 12 25 22 11 34 64 90 </span><br><span class="line">交换元素 22 和 25 后的数组: 12 22 25 11 34 64 90 </span><br><span class="line">交换元素 11 和 25 后的数组: 12 22 11 25 34 64 90 </span><br><span class="line">交换元素 11 和 22 后的数组: 12 11 22 25 34 64 90 </span><br><span class="line">交换元素 11 和 12 后的数组: 11 12 22 25 34 64 90 </span><br><span class="line">第 6 轮没有发生交换，数组已经有序。</span><br><span class="line">排序后数组: 11 12 22 25 34 64 90 </span><br></pre></td></tr></table></figure>

<h2 id="最终排序结果-1"><a href="#最终排序结果-1" class="headerlink" title="最终排序结果"></a>最终排序结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排序后数组: 11 12 22 25 34 64 90</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>冒泡排序通过多次遍历数组，比较相邻元素并在必要时进行交换，将最大的元素逐步“冒泡”到数组的末端。其主要特点包括：</p>
<ul>
<li><strong>实现简单：</strong> 适合初学者理解和实现。</li>
<li><strong>稳定性：</strong> 冒泡排序是稳定的排序算法，即相同元素的相对顺序不会改变。</li>
<li><strong>时间复杂度：</strong> 最佳情况下（已排序）为 O(n)，最坏和平均情况下为 O(n²)。</li>
<li><strong>优化措施：</strong> 通过引入 <code>swapped</code> 标志，可以在某一轮中未发生任何交换时提前终止排序，提升效率。</li>
</ul>
<p>尽管冒泡排序在效率上不及更高级的排序算法（如快速排序、归并排序等），但由于其简单性，在教学和小规模数据排序中仍有一定应用价值。通过上述示例，可以清晰地理解冒泡排序的工作机制及其逐步排序的过程。</p>
<h1 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h1><p>快速排序（Quick Sort）是一种高效的分治排序算法，由托尼·霍尔（Tony Hoare）在1960年提出。其基本思想是通过选择一个基准元素（pivot），将数组分成两部分，其中一部分所有元素都小于基准元素，另一部分所有元素都大于基准元素，然后递归地对这两部分进行排序，从而实现整个数组的有序。</p>
<h2 id="排序代码-2"><a href="#排序代码-2" class="headerlink" title="排序代码"></a>排序代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapElements</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数，选择最后一个元素作为基准</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high]; <span class="comment">// 基准元素</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>; <span class="comment">// 较小元素的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt;= high - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素小于或等于基准</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++; <span class="comment">// 增加较小元素的索引</span></span><br><span class="line">            <span class="built_in">swapElements</span>(arr[i], arr[j]);</span><br><span class="line">            <span class="comment">// 输出当前交换的元素及数组状态</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;交换元素 &quot;</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; 和 &quot;</span> &lt;&lt; arr[j] &lt;&lt; <span class="string">&quot; 后的数组: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swapElements</span>(arr[i + <span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="comment">// 输出基准元素交换后的数组状态</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;将基准元素 &quot;</span> &lt;&lt; arr[i + <span class="number">1</span>] &lt;&lt; <span class="string">&quot; 和 &quot;</span> &lt;&lt; arr[high] &lt;&lt; <span class="string">&quot; 交换后数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// pi 是分区后的基准索引，arr[pi] 已经到正确位置</span></span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归排序基准左边的子数组</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;递归排序左子数组: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = low; k &lt; pi; k++) cout &lt;&lt; arr[k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归排序基准右边的子数组</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;递归排序右子数组: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = pi + <span class="number">1</span>; k &lt;= high; k++) cout &lt;&lt; arr[k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n排序过程:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">quickSort</span>(data, <span class="number">0</span>, data.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码说明-2"><a href="#代码说明-2" class="headerlink" title="代码说明"></a>代码说明</h2><ol>
<li><strong>包含头文件和命名空间：</strong><ul>
<li><code>#include &lt;iostream&gt;</code> 和 <code>#include &lt;vector&gt;</code>：用于输入输出和使用向量容器。</li>
<li><code>using namespace std;</code>：简化标准库的使用。</li>
</ul>
</li>
<li><strong>交换函数 (<code>swapElements</code>)：</strong><ul>
<li>接受两个整数引用作为参数，并交换它们的值。</li>
<li>使用临时变量 <code>temp</code> 来暂存一个值，完成交换。</li>
</ul>
</li>
<li><strong>分区函数 (<code>partition</code>)：</strong><ul>
<li>参数：<ul>
<li><code>arr</code>：待排序的数组。</li>
<li><code>low</code> 和 <code>high</code>：当前子数组的起始和结束索引。</li>
</ul>
</li>
<li>过程：<ul>
<li>选择子数组的最后一个元素作为基准 (<code>pivot</code>)。</li>
<li>初始化一个指针 <code>i</code>，指向较小元素的最后一个位置。</li>
<li>遍历子数组，从 <code>low</code> 到 <code>high - 1</code>，如果当前元素小于或等于基准，则将其与 <code>arr[i + 1]</code> 交换，并递增 <code>i</code>。</li>
<li>最后，将基准元素与 <code>arr[i + 1]</code> 交换，使基准元素位于正确的位置。</li>
</ul>
</li>
<li>输出：<ul>
<li>每次交换后，输出当前交换的元素及数组状态。</li>
<li>基准元素交换后的数组状态。</li>
</ul>
</li>
</ul>
</li>
<li><strong>快速排序函数 (<code>quickSort</code>)：</strong><ul>
<li>参数：<ul>
<li><code>arr</code>：待排序的数组。</li>
<li><code>low</code> 和 <code>high</code>：当前子数组的起始和结束索引。</li>
</ul>
</li>
<li>过程：<ul>
<li>如果 <code>low &lt; high</code>，则进行分区。</li>
<li>获取分区后的基准索引 <code>pi</code>。</li>
<li>递归地对基准左边和右边的子数组进行快速排序。</li>
</ul>
</li>
<li>输出：<ul>
<li>递归排序左子数组和右子数组时，输出当前处理的子数组元素。</li>
</ul>
</li>
</ul>
</li>
<li><strong>主函数 (<code>main</code>)：</strong><ul>
<li>初始化一个整数数组 <code>data</code>。</li>
<li>输出原始数组。</li>
<li>调用 <code>quickSort</code> 函数进行排序，并输出排序过程中的每一次交换和递归调用。</li>
<li>最后输出排序后的数组。</li>
</ul>
</li>
</ol>
<h2 id="排序流程-2"><a href="#排序流程-2" class="headerlink" title="排序流程"></a>排序流程</h2><p>假设我们有以下数组需要排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 10 7 8 9 1 5</span><br></pre></td></tr></table></figure>

<h3 id="步骤详解-2"><a href="#步骤详解-2" class="headerlink" title="步骤详解"></a>步骤详解</h3><p><strong>初始调用：<code>quickSort(arr, 0, 5)</code></strong></p>
<ul>
<li><p><strong>分区 (<code>partition(arr, 0, 5)</code>)</strong></p>
<ul>
<li><p><strong>基准元素：</strong> <code>5</code></p>
</li>
<li><p>过程：</p>
<ul>
<li><p>初始化 <code>i = -1</code></p>
</li>
<li><p>遍历 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j</span><br></pre></td></tr></table></figure>

<p> 从 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<p> 到 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>：</p>
<ol>
<li><p><code>j = 0</code>: <code>10 &gt; 5</code>，不交换。</p>
</li>
<li><p><code>j = 1</code>: <code>7 &gt; 5</code>，不交换。</p>
</li>
<li><p><code>j = 2</code>: <code>8 &gt; 5</code>，不交换。</p>
</li>
<li><p><code>j = 3</code>: <code>9 &gt; 5</code>，不交换。</p>
</li>
<li><pre><code>j = 4
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">: </span><br><span class="line"></span><br></pre></td></tr></table></figure>
1 &lt;= 5
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">，交换 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
arr[0]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">和 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
arr[4]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">：</span><br><span class="line"></span><br><span class="line">- 执行的代码：</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  swapElements(arr[0], arr[4]);</span><br></pre></td></tr></table></figure>

- 执行后的情况：

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 7 8 9 10 5</span><br></pre></td></tr></table></figure>

- 输出：

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 1 和 10 后的数组: 1 7 8 9 10 5 </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li><p>将基准元素 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p> 与 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[1]</span><br></pre></td></tr></table></figure>

<p> 交换：</p>
<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">1</span>], arr[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 5 8 9 10 7</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将基准元素 5 和 7 交换后数组: 1 5 8 9 10 7 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>分区索引：</strong> <code>1</code></p>
</li>
</ul>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换元素 1 和 10 后的数组: 1 7 8 9 10 5 </span><br><span class="line">将基准元素 5 和 7 交换后数组: 1 5 8 9 10 7 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>递归排序左子数组 (<code>quickSort(arr, 0, 0)</code>):</strong></p>
<ul>
<li><strong>条件：</strong> <code>low &gt;= high</code>，不进行任何操作。</li>
</ul>
</li>
<li><p><strong>递归排序右子数组 (<code>quickSort(arr, 2, 5)</code>):</strong></p>
<p><strong>调用：<code>quickSort(arr, 2, 5)</code></strong></p>
<ul>
<li><p><strong>分区 (<code>partition(arr, 2, 5)</code>)</strong></p>
<ul>
<li><p><strong>基准元素：</strong> <code>7</code></p>
</li>
<li><p>过程：</p>
<ul>
<li><p>初始化 <code>i = 1</code></p>
</li>
<li><p>遍历 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j</span><br></pre></td></tr></table></figure>

<p> 从 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p>到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>：</p>
<ol>
<li><code>j = 2</code>: <code>8 &gt; 7</code>，不交换。</li>
<li><code>j = 3</code>: <code>9 &gt; 7</code>，不交换。</li>
<li><code>j = 4</code>: <code>10 &gt; 7</code>，不交换。</li>
</ol>
</li>
<li><p>将基准元素 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>

<p> 与 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[2]</span><br></pre></td></tr></table></figure>

<p> 交换：</p>
<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">2</span>], arr[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 5 7 9 10 8</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将基准元素 7 和 8 交换后数组: 1 5 7 9 10 8 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>分区索引：</strong> <code>2</code></p>
</li>
</ul>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将基准元素 7 和 8 交换后数组: 1 5 7 9 10 8 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>递归排序左子数组 (<code>quickSort(arr, 2, 1)</code>):</strong></p>
<ul>
<li><strong>条件：</strong> <code>low &gt;= high</code>，不进行任何操作.</li>
</ul>
</li>
<li><p><strong>递归排序右子数组 (<code>quickSort(arr, 3, 5)</code>):</strong></p>
<p><strong>调用：<code>quickSort(arr, 3, 5)</code></strong></p>
<ul>
<li><p><strong>分区 (<code>partition(arr, 3, 5)</code>)</strong></p>
<ul>
<li><p><strong>基准元素：</strong> <code>8</code></p>
</li>
<li><p>过程：</p>
<ul>
<li><p>初始化 <code>i = 2</code></p>
</li>
<li><p>遍历 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j</span><br></pre></td></tr></table></figure>

<p> 从 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>：</p>
<ol>
<li><code>j = 3</code>: <code>9 &gt; 8</code>，不交换。</li>
<li><code>j = 4</code>: <code>10 &gt; 8</code>，不交换.</li>
</ol>
</li>
<li><p>将基准元素 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>

<p> 与 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[3]</span><br></pre></td></tr></table></figure>

<p> 交换：</p>
<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">3</span>], arr[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 5 7 8 10 9</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将基准元素 8 和 9 交换后数组: 1 5 7 8 10 9 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>分区索引：</strong> <code>3</code></p>
</li>
</ul>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将基准元素 8 和 9 交换后数组: 1 5 7 8 10 9 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>递归排序左子数组 (<code>quickSort(arr, 3, 2)</code>):</strong></p>
<ul>
<li><strong>条件：</strong> <code>low &gt;= high</code>，不进行任何操作.</li>
</ul>
</li>
<li><p><strong>递归排序右子数组 (<code>quickSort(arr, 4, 5)</code>):</strong></p>
<p><strong>调用：<code>quickSort(arr, 4, 5)</code></strong></p>
<ul>
<li><p><strong>分区 (<code>partition(arr, 4, 5)</code>)</strong></p>
<ul>
<li><p><strong>基准元素：</strong> <code>9</code></p>
</li>
<li><p>过程：</p>
<ul>
<li><p>初始化 <code>i = 3</code></p>
</li>
<li><p>遍历 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j</span><br></pre></td></tr></table></figure>

<p> 从 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>：</p>
<ol>
<li><code>j = 4</code>: <code>10 &gt; 9</code>，不交换.</li>
</ol>
</li>
<li><p>将基准元素 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>

<p> 与 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[4]</span><br></pre></td></tr></table></figure>

<p> 交换：</p>
<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">4</span>], arr[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 5 7 8 9 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将基准元素 9 和 10 交换后数组: 1 5 7 8 9 10 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>分区索引：</strong> <code>4</code></p>
</li>
</ul>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将基准元素 9 和 10 交换后数组: 1 5 7 8 9 10 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>递归排序左子数组 (<code>quickSort(arr, 4, 3)</code>):</strong></p>
<ul>
<li><strong>条件：</strong> <code>low &gt;= high</code>，不进行任何操作.</li>
</ul>
</li>
<li><p><strong>递归排序右子数组 (<code>quickSort(arr, 5, 5)</code>):</strong></p>
<ul>
<li><strong>条件：</strong> <code>low &gt;= high</code>，不进行任何操作.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="排序过程总结-2"><a href="#排序过程总结-2" class="headerlink" title="排序过程总结"></a>排序过程总结</h3><p>整个排序过程中的每一次交换及数组状态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 10 7 8 9 1 5 </span><br><span class="line">交换元素 1 和 10 后的数组: 1 7 8 9 10 5 </span><br><span class="line">将基准元素 5 和 7 交换后数组: 1 5 8 9 10 7 </span><br><span class="line">递归排序右子数组: 8 9 10 7 </span><br><span class="line">将基准元素 7 和 8 交换后数组: 1 5 7 9 10 8 </span><br><span class="line">递归排序右子数组: 9 10 8 </span><br><span class="line">将基准元素 8 和 9 交换后数组: 1 5 7 8 10 9 </span><br><span class="line">将基准元素 9 和 10 交换后数组: 1 5 7 8 9 10 </span><br><span class="line">排序后数组: 1 5 7 8 9 10 </span><br></pre></td></tr></table></figure>

<h3 id="详细排序步骤"><a href="#详细排序步骤" class="headerlink" title="详细排序步骤"></a>详细排序步骤</h3><ol>
<li><strong>初始数组：</strong> <code>10 7 8 9 1 5</code></li>
<li><strong>第一次分区（<code>low = 0</code>, <code>high = 5</code>）：</strong><ul>
<li><strong>基准元素：</strong> <code>5</code></li>
<li><strong>交换：</strong> <code>10</code> 与 <code>1</code> → 数组变为 <code>1 7 8 9 10 5</code></li>
<li><strong>交换基准元素：</strong> <code>7</code> 与 <code>5</code> → 数组变为 <code>1 5 8 9 10 7</code></li>
</ul>
</li>
<li><strong>递归排序右子数组（<code>low = 2</code>, <code>high = 5</code>）：</strong><ul>
<li><strong>子数组：</strong> <code>8 9 10 7</code></li>
<li><strong>基准元素：</strong> <code>7</code></li>
<li><strong>交换基准元素：</strong> <code>8</code> 与 <code>7</code> → 数组变为 <code>1 5 7 9 10 8</code></li>
</ul>
</li>
<li><strong>递归排序右子数组（<code>low = 3</code>, <code>high = 5</code>）：</strong><ul>
<li><strong>子数组：</strong> <code>9 10 8</code></li>
<li><strong>基准元素：</strong> <code>8</code></li>
<li><strong>交换基准元素：</strong> <code>9</code> 与 <code>8</code> → 数组变为 <code>1 5 7 8 10 9</code></li>
</ul>
</li>
<li><strong>递归排序右子数组（<code>low = 4</code>, <code>high = 5</code>）：</strong><ul>
<li><strong>子数组：</strong> <code>10 9</code></li>
<li><strong>基准元素：</strong> <code>9</code></li>
<li><strong>交换基准元素：</strong> <code>10</code> 与 <code>9</code> → 数组变为 <code>1 5 7 8 9 10</code></li>
</ul>
</li>
<li><strong>最终排序结果：</strong> <code>1 5 7 8 9 10</code></li>
</ol>
<h2 id="最终排序结果-2"><a href="#最终排序结果-2" class="headerlink" title="最终排序结果"></a>最终排序结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排序后数组: 1 5 7 8 9 10</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>快速排序（Quick Sort）通过分治的策略将数组分为更小的子数组，递归地对这些子数组进行排序，从而实现整个数组的有序。其主要特点包括：</p>
<ul>
<li><strong>高效性：</strong> 平均时间复杂度为 O(n log n)，在大多数情况下表现优异。</li>
<li><strong>分治策略：</strong> 通过分区将问题分解为更小的子问题，便于递归解决。</li>
<li><strong>不稳定性：</strong> 快速排序不是稳定的排序算法，即相同元素的相对顺序可能会改变。</li>
<li><strong>原地排序：</strong> 只需常数级的额外空间，适用于大规模数据的排序。</li>
<li><strong>基准选择的影响：</strong> 不同的基准选择会影响算法的性能，最坏情况下时间复杂度退化为 O(n²)。</li>
</ul>
<p>通过上述示例，可以清晰地理解快速排序的工作机制，包括基准元素的选择、分区过程、递归调用及最终的有序结果。快速排序因其高效性和良好的性能表现，广泛应用于各种实际场景中，是一种非常重要的排序算法。</p>
<h1 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h1><p>选择排序（Selection Sort）是一种简单直观的排序算法。其基本思想是将数组分为已排序和未排序两部分，初始时已排序部分为空。每次从未排序部分选择最小（或最大）的元素，放入已排序部分的末尾，直到整个数组有序。</p>
<h2 id="排序代码-3"><a href="#排序代码-3" class="headerlink" title="排序代码"></a>排序代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 外层循环遍历每一个元素，作为已排序部分的末尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min_idx = i; <span class="comment">// 假设当前索引为最小元素</span></span><br><span class="line">        <span class="comment">// 内层循环在未排序部分寻找最小元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min_idx]) &#123;</span><br><span class="line">                min_idx = j; <span class="comment">// 更新最小元素的索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到的最小元素不是当前位置的元素，则交换</span></span><br><span class="line">        <span class="keyword">if</span> (min_idx != i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[min_idx]);</span><br><span class="line">            <span class="comment">// 输出当前交换的元素及数组状态</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;交换元素 &quot;</span> &lt;&lt; arr[min_idx] &lt;&lt; <span class="string">&quot; 和 &quot;</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; 后的数组: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">29</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">37</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n排序过程:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">selectionSort</span>(data);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码说明-3"><a href="#代码说明-3" class="headerlink" title="代码说明"></a>代码说明</h2><ol>
<li><strong>包含头文件和命名空间：</strong><ul>
<li><code>#include &lt;iostream&gt;</code> 和 <code>#include &lt;vector&gt;</code>：用于输入输出和使用向量容器。</li>
<li><code>using namespace std;</code>：简化标准库的使用。</li>
</ul>
</li>
<li><strong>选择排序函数 (<code>selectionSort</code>)：</strong><ul>
<li><strong>参数：</strong> 接受一个整数向量的引用 <code>arr</code>。</li>
<li>变量：<ul>
<li><code>n</code>：数组的大小。</li>
</ul>
</li>
<li><strong>外层循环 (<code>for (int i = 0; i &lt; n - 1; i++)</code>)：</strong> 遍历数组的每一个元素，假设其为当前未排序部分的最小元素。</li>
<li><strong>内层循环 (<code>for (int j = i + 1; j &lt; n; j++)</code>)：</strong> 在未排序部分寻找真正的最小元素。</li>
<li><strong>更新最小元素索引：</strong> 如果发现 <code>arr[j] &lt; arr[min_idx]</code>，则更新 <code>min_idx</code>。</li>
<li><strong>交换元素：</strong> 如果找到的最小元素索引 <code>min_idx</code> 与当前索引 <code>i</code> 不同，则交换 <code>arr[i]</code> 和 <code>arr[min_idx]</code>，并输出当前数组状态。</li>
</ul>
</li>
<li><strong>主函数 (<code>main</code>)：</strong><ul>
<li><strong>初始化数组：</strong> <code>vector&lt;int&gt; data = &#123;29, 10, 14, 37, 13&#125;;</code></li>
<li><strong>输出原始数组。</strong></li>
<li><strong>调用 <code>selectionSort</code> 函数进行排序，并输出排序过程中的每一次交换。</strong></li>
<li><strong>输出排序后的数组。</strong></li>
</ul>
</li>
</ol>
<h2 id="排序流程-3"><a href="#排序流程-3" class="headerlink" title="排序流程"></a>排序流程</h2><p>假设我们有以下数组需要排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 29 10 14 37 13</span><br></pre></td></tr></table></figure>

<h3 id="步骤详解-3"><a href="#步骤详解-3" class="headerlink" title="步骤详解"></a>步骤详解</h3><p><strong>外层循环 <code>i = 0</code>（第1轮）：</strong></p>
<ul>
<li><p><strong>假设最小元素索引 <code>min_idx = 0</code>（值为29）。</strong></p>
</li>
<li><p>内层循环寻找最小元素：</p>
<ul>
<li><code>j = 1</code>: <code>10 &lt; 29</code>，更新 <code>min_idx = 1</code></li>
<li><code>j = 2</code>: <code>14 &gt; 10</code>，<code>min_idx</code> 不变</li>
<li><code>j = 3</code>: <code>37 &gt; 10</code>，<code>min_idx</code> 不变</li>
<li><code>j = 4</code>: <code>13 &gt; 10</code>，<code>min_idx</code> 不变</li>
</ul>
</li>
<li><p>找到最小元素 <code>10</code> 在索引 <code>1</code>，与索引 <code>0</code> 的元素 <code>29</code> 交换。</p>
<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 29 14 37 13</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 10 和 29 后的数组: 10 29 14 37 13 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>外层循环 <code>i = 1</code>（第2轮）：</strong></p>
<ul>
<li><p><strong>假设最小元素索引 <code>min_idx = 1</code>（值为29）。</strong></p>
</li>
<li><p>内层循环寻找最小元素：</p>
<ul>
<li><code>j = 2</code>: <code>14 &lt; 29</code>，更新 <code>min_idx = 2</code></li>
<li><code>j = 3</code>: <code>37 &gt; 14</code>，<code>min_idx</code> 不变</li>
<li><code>j = 4</code>: <code>13 &lt; 14</code>，更新 <code>min_idx = 4</code></li>
</ul>
</li>
<li><p>找到最小元素 <code>13</code> 在索引 <code>4</code>，与索引 <code>1</code> 的元素 <code>29</code> 交换。</p>
<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">1</span>], arr[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 13 14 37 29</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 13 和 29 后的数组: 10 13 14 37 29 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>外层循环 <code>i = 2</code>（第3轮）：</strong></p>
<ul>
<li><strong>假设最小元素索引 <code>min_idx = 2</code>（值为14）。</strong></li>
<li>内层循环寻找最小元素：<ul>
<li><code>j = 3</code>: <code>37 &gt; 14</code>，<code>min_idx</code> 不变</li>
<li><code>j = 4</code>: <code>29 &gt; 14</code>，<code>min_idx</code> 不变</li>
</ul>
</li>
<li>找到最小元素 <code>14</code> 在索引 <code>2</code>，与自身交换（无需交换）。<ul>
<li><strong>无需交换，数组保持不变。</strong></li>
<li><strong>输出：</strong> 无变化</li>
</ul>
</li>
</ul>
<p><strong>外层循环 <code>i = 3</code>（第4轮）：</strong></p>
<ul>
<li><p><strong>假设最小元素索引 <code>min_idx = 3</code>（值为37）。</strong></p>
</li>
<li><p>内层循环寻找最小元素：</p>
<ul>
<li><code>j = 4</code>: <code>29 &lt; 37</code>，更新 <code>min_idx = 4</code></li>
</ul>
</li>
<li><p>找到最小元素 <code>29</code> 在索引 <code>4</code>，与索引 <code>3</code> 的元素 <code>37</code> 交换。</p>
<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(arr[<span class="number">3</span>], arr[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 13 14 29 37</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换元素 29 和 37 后的数组: 10 13 14 29 37 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>外层循环 <code>i = 4</code>（第5轮）：</strong></p>
<ul>
<li><strong>已达到倒数第二个元素，无需进一步操作。</strong></li>
</ul>
<h3 id="排序过程总结-3"><a href="#排序过程总结-3" class="headerlink" title="排序过程总结"></a>排序过程总结</h3><p>整个排序过程中的每一次交换及数组状态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 29 10 14 37 13 </span><br><span class="line">交换元素 10 和 29 后的数组: 10 29 14 37 13 </span><br><span class="line">交换元素 13 和 29 后的数组: 10 13 14 37 29 </span><br><span class="line">交换元素 29 和 37 后的数组: 10 13 14 29 37 </span><br><span class="line">排序后数组: 10 13 14 29 37 </span><br></pre></td></tr></table></figure>

<h2 id="最终排序结果-3"><a href="#最终排序结果-3" class="headerlink" title="最终排序结果"></a>最终排序结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排序后数组: 10 13 14 29 37</span><br></pre></td></tr></table></figure>

<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>选择排序通过多次选择未排序部分的最小元素，并将其放置在已排序部分的末尾，从而逐步构建有序数组。其主要特点包括：</p>
<ul>
<li><strong>实现简单：</strong> 适合初学者理解和实现。</li>
<li><strong>时间复杂度：</strong> 无论数组是否有序，时间复杂度均为 O(n²)，其中 n 是数组的大小。</li>
<li><strong>空间复杂度：</strong> 原地排序，仅需常数级额外空间。</li>
<li><strong>不稳定性：</strong> 选择排序不是稳定的排序算法，即相同元素的相对顺序可能会改变。</li>
<li><strong>交换次数较少：</strong> 相比冒泡排序，选择排序的交换次数较少，因为每轮只进行最多一次交换。</li>
</ul>
<p>尽管选择排序在效率上不及更高级的排序算法（如快速排序、归并排序等），但由于其简单性和易于理解的特性，在教学和某些特定应用中仍有一定的应用价值。通过上述示例，可以清晰地理解选择排序的工作机制，包括最小元素的选择、交换过程及最终的有序结果。</p>
<h1 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h1><p>堆排序（Heap Sort）是一种基于<strong>堆</strong>数据结构的比较型排序算法。它利用堆的性质，将待排序的数组转化为一个最大堆（或最小堆），然后依次将堆顶元素（最大或最小）与堆的最后一个元素交换，缩小堆的范围，重复此过程直到整个数组有序。堆排序的时间复杂度为O(n log n)，且是一种原地排序算法。</p>
<h2 id="排序代码-4"><a href="#排序代码-4" class="headerlink" title="排序代码"></a>排序代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapElements</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆化函数，将子树转换为最大堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;         <span class="comment">// 初始化最大元素为根节点</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;    <span class="comment">// 左子节点索引</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;   <span class="comment">// 右子节点索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点存在且大于根节点</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点存在且大于目前最大的元素</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大元素不是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swapElements</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="comment">// 递归堆化受影响的子树</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">        <span class="comment">// 输出堆化后的数组状态</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;堆化节点 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 后的数组: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个个从堆中取出元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 将当前最大的元素移到数组末尾</span></span><br><span class="line">        <span class="built_in">swapElements</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="comment">// 输出交换后的数组状态</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;将堆顶元素 &quot;</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; 移到末尾后数组: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新堆化剩余的堆</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 输出重新堆化后的数组状态</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;重新堆化后数组: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;-----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">4</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n排序过程:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">heapSort</span>(data);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码说明-4"><a href="#代码说明-4" class="headerlink" title="代码说明"></a>代码说明</h2><ol>
<li><strong>包含头文件和命名空间：</strong><ul>
<li><code>#include &lt;iostream&gt;</code> 和 <code>#include &lt;vector&gt;</code>：用于输入输出和使用向量容器。</li>
<li><code>using namespace std;</code>：简化标准库的使用。</li>
</ul>
</li>
<li><strong>交换函数 (<code>swapElements</code>)：</strong><ul>
<li>接受两个整数引用作为参数，并交换它们的值。</li>
<li>使用临时变量 <code>temp</code> 来暂存一个值，完成交换。</li>
</ul>
</li>
<li><strong>堆化函数 (<code>heapify</code>)：</strong><ul>
<li>参数：<ul>
<li><code>arr</code>：待排序的数组。</li>
<li><code>n</code>：堆的大小。</li>
<li><code>i</code>：当前堆化的根节点索引。</li>
</ul>
</li>
<li>过程：<ul>
<li>初始化 <code>largest</code> 为根节点。</li>
<li>比较左子节点和右子节点，找出最大的元素。</li>
<li>如果最大的元素不是根节点，交换它们，并递归地堆化受影响的子树。</li>
</ul>
</li>
<li>输出：<ul>
<li>在构建最大堆的过程中，输出每次堆化后的数组状态。</li>
</ul>
</li>
</ul>
</li>
<li><strong>堆排序函数 (<code>heapSort</code>)：</strong><ul>
<li><strong>参数：</strong> 接受一个整数向量的引用 <code>arr</code>。</li>
<li>过程：<ul>
<li>构建最大堆：<ul>
<li>从最后一个非叶子节点开始，向上堆化整个数组，确保堆的性质。</li>
</ul>
</li>
<li>排序过程：<ul>
<li>将堆顶元素（最大值）与数组的最后一个元素交换。</li>
<li>减小堆的大小，重新堆化剩余的堆。</li>
<li>重复此过程，直到堆的大小为1。</li>
</ul>
</li>
</ul>
</li>
<li>输出：<ul>
<li>在每次交换堆顶元素与末尾元素后，输出交换后的数组状态。</li>
<li>重新堆化后的数组状态。</li>
</ul>
</li>
</ul>
</li>
<li><strong>主函数 (<code>main</code>)：</strong><ul>
<li><strong>初始化数组：</strong> <code>vector&lt;int&gt; data = &#123;4, 10, 3, 5, 1&#125;;</code></li>
<li><strong>输出原始数组。</strong></li>
<li><strong>调用 <code>heapSort</code> 函数进行排序，并输出排序过程中的每一步状态。</strong></li>
<li><strong>输出排序后的数组。</strong></li>
</ul>
</li>
</ol>
<h2 id="排序流程-4"><a href="#排序流程-4" class="headerlink" title="排序流程"></a>排序流程</h2><p>假设我们有以下数组需要排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 4 10 3 5 1</span><br></pre></td></tr></table></figure>

<h3 id="步骤详解-4"><a href="#步骤详解-4" class="headerlink" title="步骤详解"></a>步骤详解</h3><p><strong>初始数组：</strong> <code>4 10 3 5 1</code></p>
<p><strong>构建最大堆阶段：</strong></p>
<p>堆构建从最后一个非叶子节点开始。对于长度为5的数组，最后一个非叶子节点索引为 <code>n/2 - 1 = 1</code>。</p>
<ol>
<li><p><strong>堆化节点 <code>i = 1</code>：</strong></p>
<ul>
<li><p><strong>当前节点值：</strong> <code>10</code></p>
</li>
<li><p><strong>左子节点索引：</strong> <code>3</code>（值为5）</p>
</li>
<li><p><strong>右子节点索引：</strong> <code>4</code>（值为1）</p>
</li>
<li><p><strong>比较：</strong> <code>10</code> 与 <code>5</code> 和 <code>1</code>，<code>10</code> 是最大的，无需交换。</p>
</li>
<li><p><strong>执行的代码：</strong> 无交换。</p>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 10 3 5 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">堆化节点 1 后的数组: 4 10 3 5 1 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>堆化节点 <code>i = 0</code>：</strong></p>
<ul>
<li><p><strong>当前节点值：</strong> <code>4</code></p>
</li>
<li><p><strong>左子节点索引：</strong> <code>1</code>（值为10）</p>
</li>
<li><p><strong>右子节点索引：</strong> <code>2</code>（值为3）</p>
</li>
<li><p><strong>比较：</strong> <code>4</code> 与 <code>10</code> 和 <code>3</code>，<code>10</code> 是最大的。</p>
</li>
<li><p>交换 <code>4</code> 和 <code>10</code>。</p>
<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 4 3 5 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">堆化节点 0 后的数组: 10 4 3 5 1 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>递归堆化受影响的子树（<code>i = 1</code>）：</p>
<ul>
<li><p><strong>当前节点值：</strong> <code>4</code></p>
</li>
<li><p><strong>左子节点索引：</strong> <code>3</code>（值为5）</p>
</li>
<li><p><strong>右子节点索引：</strong> <code>4</code>（值为1）</p>
</li>
<li><p><strong>比较：</strong> <code>4</code> 与 <code>5</code> 和 <code>1</code>，<code>5</code> 是最大的。</p>
</li>
<li><p>交换 <code>4</code> 和 <code>5</code>。</p>
<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">1</span>], arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 5 3 4 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">堆化节点 1 后的数组: 10 5 3 4 1 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>再次递归堆化受影响的子树（<code>i = 3</code>）：</p>
<ul>
<li><strong>当前节点索引：</strong> <code>3</code>，是叶子节点，无需堆化。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>最终堆构建完成，最大堆为：</strong> <code>10 5 3 4 1</code></p>
</li>
</ul>
</li>
</ol>
<p><strong>堆构建阶段输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">堆化节点 1 后的数组: 4 10 3 5 1 </span><br><span class="line">堆化节点 0 后的数组: 10 4 3 5 1 </span><br><span class="line">堆化节点 1 后的数组: 10 5 3 4 1 </span><br></pre></td></tr></table></figure>

<p><strong>排序阶段：</strong></p>
<ol>
<li><p><strong>第一次交换：</strong></p>
<ul>
<li><p><strong>堆顶元素（最大值）:</strong> <code>10</code></p>
</li>
<li><p>与末尾元素交换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<p> 和 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">0</span>], arr[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 5 3 4 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将堆顶元素 10 移到末尾后数组: 1 5 3 4 10 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重新堆化剩余的堆（<code>n = 4</code>，<code>i = 0</code>）：</p>
<ul>
<li><p><strong>当前堆：</strong> <code>1 5 3 4</code></p>
</li>
<li><p>堆化节点 <code>i = 0</code>：</p>
<ul>
<li><p><strong>当前节点值：</strong> <code>1</code></p>
</li>
<li><p><strong>左子节点索引：</strong> <code>1</code>（值为5）</p>
</li>
<li><p><strong>右子节点索引：</strong> <code>2</code>（值为3）</p>
</li>
<li><p><strong>比较：</strong> <code>1</code> 与 <code>5</code> 和 <code>3</code>，<code>5</code> 是最大的。</p>
</li>
<li><p>交换 <code>1</code> 和 <code>5</code>。</p>
<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 1 3 4 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重新堆化后数组: 5 1 3 4 10 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>递归堆化受影响的子树（<code>i = 1</code>）：</p>
<ul>
<li><p><strong>当前节点值：</strong> <code>1</code></p>
</li>
<li><p><strong>左子节点索引：</strong> <code>3</code>（值为4）</p>
</li>
<li><p><strong>右子节点索引：</strong> <code>4</code>（超出范围）</p>
</li>
<li><p><strong>比较：</strong> <code>1</code> 与 <code>4</code>，<code>4</code> 是最大的。</p>
</li>
<li><p>交换 <code>1</code> 和 <code>4</code>。</p>
<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">1</span>], arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 4 3 1 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重新堆化后数组: 5 4 3 1 10 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>最终重新堆化后的堆：</strong> <code>5 4 3 1 10</code></p>
</li>
</ul>
</li>
<li><p>排序阶段输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将堆顶元素 10 移到末尾后数组: 1 5 3 4 10 </span><br><span class="line">重新堆化后数组: 5 1 3 4 10 </span><br><span class="line">重新堆化后数组: 5 4 3 1 10 </span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>第二次交换：</strong></p>
<ul>
<li><p><strong>堆顶元素（最大值）:</strong> <code>5</code></p>
</li>
<li><p>与末尾元素交换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p> 和 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">0</span>], arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4 3 5 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将堆顶元素 5 移到末尾后数组: 1 4 3 5 10 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重新堆化剩余的堆（<code>n = 3</code>，<code>i = 0</code>）：</p>
<ul>
<li><p><strong>当前堆：</strong> <code>1 4 3</code></p>
</li>
<li><p>堆化节点 <code>i = 0</code>：</p>
<ul>
<li><p><strong>当前节点值：</strong> <code>1</code></p>
</li>
<li><p><strong>左子节点索引：</strong> <code>1</code>（值为4）</p>
</li>
<li><p><strong>右子节点索引：</strong> <code>2</code>（值为3）</p>
</li>
<li><p><strong>比较：</strong> <code>1</code> 与 <code>4</code> 和 <code>3</code>，<code>4</code> 是最大的。</p>
</li>
<li><p>交换 <code>1</code> 和 <code>4</code>。</p>
<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 1 3 5 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重新堆化后数组: 4 1 3 5 10 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>递归堆化受影响的子树（<code>i = 1</code>）：</p>
<ul>
<li><strong>当前节点值：</strong> <code>1</code></li>
<li><strong>左子节点索引：</strong> <code>3</code>（超出范围）</li>
<li><strong>无需堆化。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>排序阶段输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将堆顶元素 5 移到末尾后数组: 1 4 3 5 10 </span><br><span class="line">重新堆化后数组: 4 1 3 5 10 </span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>第三次交换：</strong></p>
<ul>
<li><p><strong>堆顶元素（最大值）:</strong> <code>4</code></p>
</li>
<li><p>与末尾元素交换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p> 和 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">0</span>], arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 4 5 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将堆顶元素 4 移到末尾后数组: 1 1 4 5 10 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重新堆化剩余的堆（<code>n = 2</code>，<code>i = 0</code>）：</p>
<ul>
<li><strong>当前堆：</strong> <code>1 1</code></li>
<li>堆化节点 <code>i = 0</code>：<ul>
<li><strong>当前节点值：</strong> <code>1</code></li>
<li><strong>左子节点索引：</strong> <code>1</code>（值为1）</li>
<li><strong>右子节点索引：</strong> <code>2</code>（超出范围）</li>
<li><strong>比较：</strong> <code>1</code> 与 <code>1</code>，无需交换。</li>
</ul>
</li>
</ul>
</li>
<li><p>排序阶段输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将堆顶元素 4 移到末尾后数组: 1 1 4 5 10 </span><br><span class="line">重新堆化后数组: 1 1 4 5 10 </span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>第四次交换：</strong></p>
<ul>
<li><p><strong>堆顶元素（最大值）:</strong> <code>1</code></p>
</li>
<li><p>与末尾元素交换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p> 和 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>（无实际变化）</p>
<ul>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swapElements</span>(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 4 5 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将堆顶元素 1 移到末尾后数组: 1 1 4 5 10 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重新堆化剩余的堆（<code>n = 1</code>，<code>i = 0</code>）：</p>
<ul>
<li><strong>当前堆：</strong> <code>1</code></li>
<li><strong>无需堆化。</strong></li>
</ul>
</li>
<li><p>排序阶段输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将堆顶元素 1 移到末尾后数组: 1 1 4 5 10 </span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>排序过程总结：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 4 10 3 5 1 </span><br><span class="line">堆化节点 1 后的数组: 4 10 3 5 1 </span><br><span class="line">堆化节点 0 后的数组: 10 4 3 5 1 </span><br><span class="line">堆化节点 1 后的数组: 10 5 3 4 1 </span><br><span class="line">堆化节点 3 后的数组: 10 5 3 4 1 </span><br><span class="line">将堆顶元素 10 移到末尾后数组: 1 5 3 4 10 </span><br><span class="line">重新堆化后数组: 5 1 3 4 10 </span><br><span class="line">重新堆化后数组: 5 4 3 1 10 </span><br><span class="line">-----------------------------</span><br><span class="line">将堆顶元素 5 移到末尾后数组: 1 4 3 5 10 </span><br><span class="line">重新堆化后数组: 4 1 3 5 10 </span><br><span class="line">-----------------------------</span><br><span class="line">将堆顶元素 4 移到末尾后数组: 1 1 4 5 10 </span><br><span class="line">重新堆化后数组: 1 1 4 5 10 </span><br><span class="line">-----------------------------</span><br><span class="line">将堆顶元素 1 移到末尾后数组: 1 1 4 5 10 </span><br><span class="line">-----------------------------</span><br><span class="line">排序后数组: 1 1 4 5 10 </span><br></pre></td></tr></table></figure>

<h3 id="详细排序步骤-1"><a href="#详细排序步骤-1" class="headerlink" title="详细排序步骤"></a>详细排序步骤</h3><ol>
<li><p><strong>初始数组：</strong> <code>4 10 3 5 1</code></p>
</li>
<li><p><strong>构建最大堆：</strong></p>
<ul>
<li><strong>堆化节点 1（值为10）：</strong> 无需交换，堆化后数组保持 <code>4 10 3 5 1</code></li>
<li>堆化节点 0（值为4）：<ul>
<li>与左子节点 <code>10</code> 交换，数组变为 <code>10 4 3 5 1</code></li>
<li>递归堆化节点 1（值为4）：<ul>
<li>与左子节点 <code>5</code> 交换，数组变为 <code>10 5 3 4 1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>排序过程：</strong></p>
<ul>
<li><p>第一次交换：</p>
<ul>
<li><p>将堆顶 <code>10</code> 与末尾 <code>1</code> 交换，数组变为 <code>1 5 3 4 10</code></p>
</li>
<li><p>重新堆化剩余堆 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 5 3 4</span><br></pre></td></tr></table></figure>

<p>：</p>
<ul>
<li>与左子节点 <code>5</code> 交换，数组变为 <code>5 1 3 4 10</code></li>
<li>递归堆化节点 1（值为1）：<ul>
<li>与左子节点 <code>4</code> 交换，数组变为 <code>5 4 3 1 10</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第二次交换：</p>
<ul>
<li><p>将堆顶 <code>5</code> 与末尾 <code>1</code> 交换，数组变为 <code>1 4 3 5 10</code></p>
</li>
<li><p>重新堆化剩余堆 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4 3</span><br></pre></td></tr></table></figure>

<p>：</p>
<ul>
<li>与左子节点 <code>4</code> 交换，数组变为 <code>4 1 3 5 10</code></li>
</ul>
</li>
</ul>
</li>
<li><p>第三次交换：</p>
<ul>
<li>将堆顶 <code>4</code> 与末尾 <code>1</code> 交换，数组变为 <code>1 1 4 5 10</code></li>
<li>重新堆化剩余堆 <code>1</code>：无需操作</li>
</ul>
</li>
<li><p>第四次交换：</p>
<ul>
<li>将堆顶 <code>1</code> 与末尾 <code>1</code> 交换，数组保持不变 <code>1 1 4 5 10</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>最终排序结果：</strong> <code>1 1 4 5 10</code></p>
</li>
</ol>
<h2 id="最终排序结果-4"><a href="#最终排序结果-4" class="headerlink" title="最终排序结果"></a>最终排序结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排序后数组: 1 1 4 5 10 </span><br></pre></td></tr></table></figure>

<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>堆排序（Heap Sort）通过构建最大堆（或最小堆），利用堆的性质将数组有序化。其主要特点包括：</p>
<ul>
<li><strong>时间复杂度：</strong> 无论最佳、平均还是最坏情况，时间复杂度均为O(n log n)。</li>
<li><strong>空间复杂度：</strong> 原地排序，仅需常数级额外空间。</li>
<li><strong>不稳定性：</strong> 堆排序不是稳定的排序算法，即相同元素的相对顺序可能会改变。</li>
<li><strong>适用性：</strong> 适用于大规模数据的排序，特别是在需要原地排序且不关心稳定性的场景。</li>
<li><strong>实现复杂度：</strong> 相较于冒泡排序和选择排序，堆排序的实现稍显复杂，但由于其更优的时间复杂度，适用于更广泛的应用。</li>
</ul>
<p>通过上述示例，可以清晰地理解堆排序的工作机制，包括最大堆的构建、堆顶元素的交换、重新堆化过程及最终的有序结果。堆排序因其高效性和稳定的时间复杂度，在实际应用中具有重要的价值。</p>
<h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><p>归并排序（Merge Sort）是一种高效、稳定的排序算法，采用<strong>分治法（Divide and Conquer）</strong>的策略。它将数组递归地分割成两半，分别排序，然后将排序后的子数组合并成一个有序的数组。归并排序的时间复杂度为O(n log n)，且空间复杂度为O(n)，适用于大规模数据的排序。</p>
<h2 id="排序代码-5"><a href="#排序代码-5" class="headerlink" title="排序代码"></a>排序代码</h2><p>以下是归并排序的C++实现，包含详细的注释以帮助理解每一步的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序子数组 arr[left..mid] 和 arr[mid+1..right]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建临时数组来存储合并后的结果</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = left;     <span class="comment">// 左子数组的起始索引</span></span><br><span class="line">    <span class="type">int</span> j = mid + <span class="number">1</span>;  <span class="comment">// 右子数组的起始索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个子数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(arr[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制左子数组中剩余的元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制右子数组中剩余的元素</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(arr[j]);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将合并后的元素复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">        arr[k] = temp[k - left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出当前合并后的数组状态</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;合并后数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序的递归函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 计算中间索引，避免溢出</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归排序左半部分</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, left, mid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归排序右半部分</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并两个有序子数组</span></span><br><span class="line">        <span class="built_in">merge</span>(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">38</span>, <span class="number">27</span>, <span class="number">43</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">82</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(data);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n排序过程:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">mergeSort</span>(data, <span class="number">0</span>, data.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n排序后数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码说明-5"><a href="#代码说明-5" class="headerlink" title="代码说明"></a>代码说明</h2><ol>
<li><strong>包含头文件和命名空间：</strong><ul>
<li><code>#include &lt;iostream&gt;</code> 和 <code>#include &lt;vector&gt;</code>：用于输入输出和使用向量容器。</li>
<li><code>using namespace std;</code>：简化标准库的使用。</li>
</ul>
</li>
<li><strong>合并函数 (<code>merge</code>)：</strong><ul>
<li>参数：<ul>
<li><code>arr</code>：待排序的数组。</li>
<li><code>left</code> 和 <code>right</code>：当前子数组的起始和结束索引。</li>
<li><code>mid</code>：当前子数组的中间索引。</li>
</ul>
</li>
<li>过程：<ul>
<li>创建一个临时数组 <code>temp</code> 来存储合并后的结果。</li>
<li>使用两个指针 <code>i</code> 和 <code>j</code> 分别指向左子数组和右子数组的起始位置。</li>
<li>比较 <code>arr[i]</code> 和 <code>arr[j]</code>，将较小的元素添加到 <code>temp</code> 中，并移动相应的指针。</li>
<li>将剩余的元素（如果有）添加到 <code>temp</code> 中。</li>
<li>将合并后的结果复制回原数组 <code>arr</code> 的相应位置。</li>
</ul>
</li>
<li>输出：<ul>
<li>每次合并后，输出当前合并后的数组状态。</li>
</ul>
</li>
</ul>
</li>
<li><strong>归并排序函数 (<code>mergeSort</code>)：</strong><ul>
<li>参数：<ul>
<li><code>arr</code>：待排序的数组。</li>
<li><code>left</code> 和 <code>right</code>：当前子数组的起始和结束索引。</li>
</ul>
</li>
<li>过程：<ul>
<li>如果 <code>left &lt; right</code>，则继续分割数组。</li>
<li>计算中间索引 <code>mid</code>，避免整数溢出。</li>
<li>递归地对左半部分 <code>arr[left..mid]</code> 进行归并排序。</li>
<li>递归地对右半部分 <code>arr[mid+1..right]</code> 进行归并排序。</li>
<li>合并排序后的两部分。</li>
</ul>
</li>
</ul>
</li>
<li><strong>打印数组函数 (<code>printArray</code>)：</strong><ul>
<li>接受一个整数向量，并打印其内容。</li>
</ul>
</li>
<li><strong>主函数 (<code>main</code>)：</strong><ul>
<li>初始化一个整数数组 <code>data</code>。</li>
<li>输出原始数组。</li>
<li>调用 <code>mergeSort</code> 函数进行排序，并输出排序过程中的每一步合并状态。</li>
<li>最后输出排序后的数组。</li>
</ul>
</li>
</ol>
<h2 id="排序流程-5"><a href="#排序流程-5" class="headerlink" title="排序流程"></a>排序流程</h2><p>假设我们有以下数组需要排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 38 27 43 3 9 82 10</span><br></pre></td></tr></table></figure>

<h3 id="步骤详解-5"><a href="#步骤详解-5" class="headerlink" title="步骤详解"></a>步骤详解</h3><p>归并排序通过不断地将数组分割，直到每个子数组只有一个元素，然后合并这些子数组，使其有序。以下是详细的排序流程：</p>
<h4 id="1-初始调用：mergeSort-arr-0-6"><a href="#1-初始调用：mergeSort-arr-0-6" class="headerlink" title="1. 初始调用：mergeSort(arr, 0, 6)"></a>1. 初始调用：<code>mergeSort(arr, 0, 6)</code></h4><ul>
<li><strong>数组范围：</strong> <code>0</code> 到 <code>6</code>（包含元素 <code>38, 27, 43, 3, 9, 82, 10</code>）</li>
<li><strong>中间索引：</strong> <code>mid = 0 + (6 - 0) / 2 = 3</code></li>
<li>递归调用：<ul>
<li><code>mergeSort(arr, 0, 3)</code></li>
<li><code>mergeSort(arr, 4, 6)</code></li>
</ul>
</li>
</ul>
<h4 id="2-左半部分排序：mergeSort-arr-0-3"><a href="#2-左半部分排序：mergeSort-arr-0-3" class="headerlink" title="2. 左半部分排序：mergeSort(arr, 0, 3)"></a>2. 左半部分排序：<code>mergeSort(arr, 0, 3)</code></h4><ul>
<li><strong>数组范围：</strong> <code>0</code> 到 <code>3</code>（包含元素 <code>38, 27, 43, 3</code>）</li>
<li><strong>中间索引：</strong> <code>mid = 0 + (3 - 0) / 2 = 1</code></li>
<li>递归调用：<ul>
<li><code>mergeSort(arr, 0, 1)</code></li>
<li><code>mergeSort(arr, 2, 3)</code></li>
</ul>
</li>
</ul>
<h5 id="2-1-左子数组排序：mergeSort-arr-0-1"><a href="#2-1-左子数组排序：mergeSort-arr-0-1" class="headerlink" title="2.1. 左子数组排序：mergeSort(arr, 0, 1)"></a>2.1. 左子数组排序：<code>mergeSort(arr, 0, 1)</code></h5><ul>
<li><strong>数组范围：</strong> <code>0</code> 到 <code>1</code>（包含元素 <code>38, 27</code>）</li>
<li><strong>中间索引：</strong> <code>mid = 0 + (1 - 0) / 2 = 0</code></li>
<li>递归调用：<ul>
<li><code>mergeSort(arr, 0, 0)</code>：单个元素，无需排序。</li>
<li><code>mergeSort(arr, 1, 1)</code>：单个元素，无需排序。</li>
</ul>
</li>
<li><strong>合并子数组：</strong> <code>merge(arr, 0, 0, 1)</code></li>
</ul>
<h6 id="合并-arr-0-0-和-arr-1-1"><a href="#合并-arr-0-0-和-arr-1-1" class="headerlink" title="合并 arr[0..0] 和 arr[1..1]"></a>合并 <code>arr[0..0]</code> 和 <code>arr[1..1]</code></h6><ul>
<li><p><strong>待合并的子数组：</strong> <code>38</code> 和 <code>27</code></p>
</li>
<li><p>比较：</p>
<ul>
<li><code>38 &gt; 27</code>，将 <code>27</code> 添加到 <code>temp</code>，然后将 <code>38</code> 添加到 <code>temp</code>。</li>
</ul>
</li>
<li><p><strong>合并结果：</strong> <code>27, 38</code></p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">merge</span>(arr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">27 38 43 3 9 82 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">合并后数组: 27 38 </span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-2-右子数组排序：mergeSort-arr-2-3"><a href="#2-2-右子数组排序：mergeSort-arr-2-3" class="headerlink" title="2.2. 右子数组排序：mergeSort(arr, 2, 3)"></a>2.2. 右子数组排序：<code>mergeSort(arr, 2, 3)</code></h5><ul>
<li><strong>数组范围：</strong> <code>2</code> 到 <code>3</code>（包含元素 <code>43, 3</code>）</li>
<li><strong>中间索引：</strong> <code>mid = 2 + (3 - 2) / 2 = 2</code></li>
<li>递归调用：<ul>
<li><code>mergeSort(arr, 2, 2)</code>：单个元素，无需排序。</li>
<li><code>mergeSort(arr, 3, 3)</code>：单个元素，无需排序。</li>
</ul>
</li>
<li><strong>合并子数组：</strong> <code>merge(arr, 2, 2, 3)</code></li>
</ul>
<h6 id="合并-arr-2-2-和-arr-3-3"><a href="#合并-arr-2-2-和-arr-3-3" class="headerlink" title="合并 arr[2..2] 和 arr[3..3]"></a>合并 <code>arr[2..2]</code> 和 <code>arr[3..3]</code></h6><ul>
<li><p><strong>待合并的子数组：</strong> <code>43</code> 和 <code>3</code></p>
</li>
<li><p>比较：</p>
<ul>
<li><code>43 &gt; 3</code>，将 <code>3</code> 添加到 <code>temp</code>，然后将 <code>43</code> 添加到 <code>temp</code>。</li>
</ul>
</li>
<li><p><strong>合并结果：</strong> <code>3, 43</code></p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">merge</span>(arr, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">27 38 3 43 9 82 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">合并后数组: 3 43 </span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-3-合并左半部分和右半部分：merge-arr-0-1-3"><a href="#2-3-合并左半部分和右半部分：merge-arr-0-1-3" class="headerlink" title="2.3. 合并左半部分和右半部分：merge(arr, 0, 1, 3)"></a>2.3. 合并左半部分和右半部分：<code>merge(arr, 0, 1, 3)</code></h5><ul>
<li><p><strong>待合并的子数组：</strong> <code>27, 38</code> 和 <code>3, 43</code></p>
</li>
<li><p>比较：</p>
<ul>
<li><code>27 &gt; 3</code>，将 <code>3</code> 添加到 <code>temp</code>。</li>
<li><code>27 &lt; 43</code>，将 <code>27</code> 添加到 <code>temp</code>。</li>
<li><code>38 &lt; 43</code>，将 <code>38</code> 添加到 <code>temp</code>。</li>
<li>将剩余的 <code>43</code> 添加到 <code>temp</code>。</li>
</ul>
</li>
<li><p><strong>合并结果：</strong> <code>3, 27, 38, 43</code></p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">merge</span>(arr, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 27 38 43 9 82 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">合并后数组: 3 27 38 43 </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-右半部分排序：mergeSort-arr-4-6"><a href="#3-右半部分排序：mergeSort-arr-4-6" class="headerlink" title="3. 右半部分排序：mergeSort(arr, 4, 6)"></a>3. 右半部分排序：<code>mergeSort(arr, 4, 6)</code></h4><ul>
<li><strong>数组范围：</strong> <code>4</code> 到 <code>6</code>（包含元素 <code>9, 82, 10</code>）</li>
<li><strong>中间索引：</strong> <code>mid = 4 + (6 - 4) / 2 = 5</code></li>
<li>递归调用：<ul>
<li><code>mergeSort(arr, 4, 5)</code></li>
<li><code>mergeSort(arr, 6, 6)</code></li>
</ul>
</li>
</ul>
<h5 id="3-1-左子数组排序：mergeSort-arr-4-5"><a href="#3-1-左子数组排序：mergeSort-arr-4-5" class="headerlink" title="3.1. 左子数组排序：mergeSort(arr, 4, 5)"></a>3.1. 左子数组排序：<code>mergeSort(arr, 4, 5)</code></h5><ul>
<li><strong>数组范围：</strong> <code>4</code> 到 <code>5</code>（包含元素 <code>9, 82</code>）</li>
<li><strong>中间索引：</strong> <code>mid = 4 + (5 - 4) / 2 = 4</code></li>
<li>递归调用：<ul>
<li><code>mergeSort(arr, 4, 4)</code>：单个元素，无需排序。</li>
<li><code>mergeSort(arr, 5, 5)</code>：单个元素，无需排序。</li>
</ul>
</li>
<li><strong>合并子数组：</strong> <code>merge(arr, 4, 4, 5)</code></li>
</ul>
<h6 id="合并-arr-4-4-和-arr-5-5"><a href="#合并-arr-4-4-和-arr-5-5" class="headerlink" title="合并 arr[4..4] 和 arr[5..5]"></a>合并 <code>arr[4..4]</code> 和 <code>arr[5..5]</code></h6><ul>
<li><p><strong>待合并的子数组：</strong> <code>9</code> 和 <code>82</code></p>
</li>
<li><p>比较：</p>
<ul>
<li><code>9 &lt;= 82</code>，将 <code>9</code> 添加到 <code>temp</code>，然后将 <code>82</code> 添加到 <code>temp</code>。</li>
</ul>
</li>
<li><p><strong>合并结果：</strong> <code>9, 82</code></p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">merge</span>(arr, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 27 38 43 9 82 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">合并后数组: 9 82 </span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-2-右子数组排序：mergeSort-arr-6-6"><a href="#3-2-右子数组排序：mergeSort-arr-6-6" class="headerlink" title="3.2. 右子数组排序：mergeSort(arr, 6, 6)"></a>3.2. 右子数组排序：<code>mergeSort(arr, 6, 6)</code></h5><ul>
<li><strong>数组范围：</strong> <code>6</code> 到 <code>6</code>（包含元素 <code>10</code>）</li>
<li><strong>无需排序。</strong></li>
</ul>
<h5 id="3-3-合并左半部分和右半部分：merge-arr-4-5-6"><a href="#3-3-合并左半部分和右半部分：merge-arr-4-5-6" class="headerlink" title="3.3. 合并左半部分和右半部分：merge(arr, 4, 5, 6)"></a>3.3. 合并左半部分和右半部分：<code>merge(arr, 4, 5, 6)</code></h5><ul>
<li><p><strong>待合并的子数组：</strong> <code>9, 82</code> 和 <code>10</code></p>
</li>
<li><p>比较：</p>
<ul>
<li><code>9 &lt;= 10</code>，将 <code>9</code> 添加到 <code>temp</code>。</li>
<li><code>82 &gt; 10</code>，将 <code>10</code> 添加到 <code>temp</code>。</li>
<li>将剩余的 <code>82</code> 添加到 <code>temp</code>。</li>
</ul>
</li>
<li><p><strong>合并结果：</strong> <code>9, 10, 82</code></p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">merge</span>(arr, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 27 38 43 9 10 82</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">合并后数组: 9 10 82 </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-合并左右半部分：merge-arr-0-3-6"><a href="#4-合并左右半部分：merge-arr-0-3-6" class="headerlink" title="4. 合并左右半部分：merge(arr, 0, 3, 6)"></a>4. 合并左右半部分：<code>merge(arr, 0, 3, 6)</code></h4><ul>
<li><p><strong>待合并的子数组：</strong> <code>3, 27, 38, 43</code> 和 <code>9, 10, 82</code></p>
</li>
<li><p>比较：</p>
<ul>
<li><code>3 &lt;= 9</code>，将 <code>3</code> 添加到 <code>temp</code>。</li>
<li><code>27 &gt; 9</code>，将 <code>9</code> 添加到 <code>temp</code>。</li>
<li><code>27 &lt;= 10</code>，将 <code>10</code> 添加到 <code>temp</code>。</li>
<li><code>27 &lt;= 82</code>，将 <code>27</code> 添加到 <code>temp</code>。</li>
<li><code>38 &lt;= 82</code>，将 <code>38</code> 添加到 <code>temp</code>。</li>
<li><code>43 &lt;= 82</code>，将 <code>43</code> 添加到 <code>temp</code>。</li>
<li>将剩余的 <code>82</code> 添加到 <code>temp</code>。</li>
</ul>
</li>
<li><p><strong>合并结果：</strong> <code>3, 9, 10, 27, 38, 43, 82</code></p>
</li>
<li><p>执行的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">merge</span>(arr, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 9 10 27 38 43 82</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">合并后数组: 3 9 10 27 38 43 82 </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="排序过程总结-4"><a href="#排序过程总结-4" class="headerlink" title="排序过程总结"></a>排序过程总结</h3><p>整个排序过程中的每一次合并及数组状态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 38 27 43 3 9 82 10 </span><br><span class="line"></span><br><span class="line">合并后数组: 27 38 </span><br><span class="line">合并后数组: 3 43 </span><br><span class="line">合并后数组: 3 27 38 43 </span><br><span class="line">合并后数组: 9 82 </span><br><span class="line">合并后数组: 9 10 82 </span><br><span class="line">合并后数组: 3 9 10 27 38 43 82 </span><br><span class="line">排序后数组: 3 9 10 27 38 43 82 </span><br></pre></td></tr></table></figure>

<h3 id="详细排序步骤-2"><a href="#详细排序步骤-2" class="headerlink" title="详细排序步骤"></a>详细排序步骤</h3><ol>
<li><strong>初始数组：</strong> <code>38 27 43 3 9 82 10</code></li>
<li><strong>分割数组：</strong><ul>
<li>第一次分割：<ul>
<li>左半部分：<code>38 27 43 3</code></li>
<li>右半部分：<code>9 82 10</code></li>
</ul>
</li>
<li>第二次分割（左半部分）：<ul>
<li>左子数组：<code>38 27</code></li>
<li>右子数组：<code>43 3</code></li>
</ul>
</li>
<li>第三次分割（右半部分）：<ul>
<li>左子数组：<code>9 82</code></li>
<li>右子数组：<code>10</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>递归排序和合并：</strong><ul>
<li>排序并合并 <code>38</code> 和 <code>27</code>：<ul>
<li>合并结果：<code>27, 38</code></li>
<li>数组状态：<code>27 38 43 3 9 82 10</code></li>
</ul>
</li>
<li>排序并合并 <code>43</code> 和 <code>3</code>：<ul>
<li>合并结果：<code>3, 43</code></li>
<li>数组状态：<code>27 38 3 43 9 82 10</code></li>
</ul>
</li>
<li>合并 <code>27, 38</code> 和 <code>3, 43</code>：<ul>
<li>合并结果：<code>3, 27, 38, 43</code></li>
<li>数组状态：<code>3 27 38 43 9 82 10</code></li>
</ul>
</li>
<li>排序并合并 <code>9</code> 和 <code>82</code>：<ul>
<li>合并结果：<code>9, 82</code></li>
<li>数组状态：<code>3 27 38 43 9 82 10</code></li>
</ul>
</li>
<li>排序并合并 <code>9, 82</code> 和 <code>10</code>：<ul>
<li>合并结果：<code>9, 10, 82</code></li>
<li>数组状态：<code>3 27 38 43 9 10 82</code></li>
</ul>
</li>
<li>合并 <code>3, 27, 38, 43</code> 和 <code>9, 10, 82</code>：<ul>
<li>合并结果：<code>3, 9, 10, 27, 38, 43, 82</code></li>
<li>数组状态：<code>3 9 10 27 38 43 82</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>最终排序结果：</strong> <code>3 9 10 27 38 43 82</code></li>
</ol>
<h2 id="最终排序结果-5"><a href="#最终排序结果-5" class="headerlink" title="最终排序结果"></a>最终排序结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排序后数组: 3 9 10 27 38 43 82 </span><br></pre></td></tr></table></figure>

<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>归并排序（Merge Sort）通过<strong>分治法</strong>将数组递归地分割成更小的子数组，直到每个子数组只有一个元素（天然有序），然后将这些子数组合并成有序的更大的子数组，最终形成一个完全有序的数组。其主要特点包括：</p>
<ul>
<li><strong>时间复杂度：</strong> O(n log n)，无论最佳、平均还是最坏情况都具有相同的时间复杂度。</li>
<li><strong>空间复杂度：</strong> O(n)，需要额外的临时数组来存储合并后的结果。</li>
<li><strong>稳定性：</strong> 归并排序是稳定的排序算法，即相同元素的相对顺序不会改变。</li>
<li><strong>分治策略：</strong> 通过分割和合并的策略，解决问题。</li>
<li><strong>适用性：</strong> 适用于需要稳定排序且对额外空间要求不高的场景。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>稳定性好。</li>
<li>时间复杂度稳定。</li>
<li>适用于大规模数据的排序。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>需要额外的空间。</li>
<li>实现相对复杂。</li>
</ul>
<p>通过上述示例，可以清晰地理解归并排序的工作机制，包括数组的分割、递归排序、子数组的合并及最终的有序结果。归并排序因其稳定性和高效性，在许多实际应用中具有重要的价值，尤其是在处理大规模数据时表现尤为出色。</p>
<h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><p>基数排序（Radix Sort）是一种非比较型的<strong>稳定</strong>排序算法，适用于对整数或能够映射为整数的键进行排序。基数排序通过逐位（从最低有效位到最高有效位或反之）对数据进行排序，利用计数排序（Counting Sort）作为子过程，以实现整体的有序。基数排序的时间复杂度为O(d*(n + k))，其中d是数字的位数，n是元素数量，k是基数。</p>
<h2 id="排序代码-6"><a href="#排序代码-6" class="headerlink" title="排序代码"></a>排序代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数字的最大位数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max_num = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; max_num)</span><br><span class="line">            max_num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行计数排序，根据当前位进行排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> exp)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 输出数组</span></span><br><span class="line">    <span class="type">int</span> count[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 计数数组，基数为10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储当前位的计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        count[(arr[i] / exp) % <span class="number">10</span>]++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改变 count[i]，使其包含实际位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建输出数组，确保稳定性</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="type">int</span> digit = (arr[i] / exp) % <span class="number">10</span>;</span><br><span class="line">        output[count[digit] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        count[digit]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输出数组复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        arr[i] = output[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到最大数以确定位数</span></span><br><span class="line">    <span class="type">int</span> max_num = <span class="built_in">getMax</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最低位到最高位进行计数排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> exp = <span class="number">1</span>; max_num / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;按位排序，当前位数的权重(exp): &quot;</span> &lt;&lt; exp &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">countingSort</span>(arr, exp);</span><br><span class="line">        <span class="comment">// 输出当前排序后的数组状态</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;排序后数组: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : arr) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n-----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">170</span>, <span class="number">45</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">802</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">66</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n排序过程:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">radixSort</span>(data);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后数组: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : data) cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码说明-6"><a href="#代码说明-6" class="headerlink" title="代码说明"></a>代码说明</h2><ol>
<li><strong>包含头文件和命名空间：</strong><ul>
<li><code>#include &lt;iostream&gt;</code>、<code>#include &lt;vector&gt;</code>、<code>#include &lt;algorithm&gt;</code> 和 <code>#include &lt;cmath&gt;</code>：用于输入输出、使用向量容器、算法函数和数学运算。</li>
<li><code>using namespace std;</code>：简化标准库的使用。</li>
</ul>
</li>
<li><strong>获取最大数的函数 (<code>getMax</code>)：</strong><ul>
<li><strong>参数：</strong> 接受一个整数向量的引用 <code>arr</code>。</li>
<li><strong>过程：</strong> 遍历数组，找到最大值，以确定需要排序的位数。</li>
</ul>
</li>
<li><strong>计数排序函数 (<code>countingSort</code>)：</strong><ul>
<li>参数：<ul>
<li><code>arr</code>：待排序的数组。</li>
<li><code>exp</code>：当前排序的位数的权重（如1表示个位，10表示十位，依此类推）。</li>
</ul>
</li>
<li>过程：<ul>
<li>初始化输出数组 <code>output</code> 和计数数组 <code>count</code>。</li>
<li>遍历数组，统计每个数字在当前位上的出现次数。</li>
<li>修改计数数组，使其包含实际的位置。</li>
<li>从后向前遍历原数组，构建输出数组，确保排序的稳定性。</li>
<li>将输出数组复制回原数组。</li>
</ul>
</li>
<li><strong>输出：</strong> 每次按位排序后的数组状态在主排序函数中输出。</li>
</ul>
</li>
<li><strong>基数排序函数 (<code>radixSort</code>)：</strong><ul>
<li><strong>参数：</strong> 接受一个整数向量的引用 <code>arr</code>。</li>
<li>过程：<ul>
<li>调用 <code>getMax</code> 函数获取数组中的最大数，以确定需要进行多少位的排序。</li>
<li>从最低位（个位）开始，逐步进行计数排序，权重 <code>exp</code> 每次乘以10。</li>
<li>每次按位排序后，输出当前排序后的数组状态。</li>
</ul>
</li>
</ul>
</li>
<li><strong>主函数 (<code>main</code>)：</strong><ul>
<li>初始化一个整数数组 <code>data</code>。</li>
<li>输出原始数组。</li>
<li>调用 <code>radixSort</code> 函数进行排序，并输出排序过程中的每一步状态。</li>
<li>最后输出排序后的数组。</li>
</ul>
</li>
</ol>
<h2 id="排序流程-6"><a href="#排序流程-6" class="headerlink" title="排序流程"></a>排序流程</h2><p>假设我们有以下数组需要排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 170 45 75 90 802 24 2 66</span><br></pre></td></tr></table></figure>

<p>基数排序将从最低位（个位）开始，逐步排序到最高位。以下是详细的排序步骤：</p>
<h3 id="第1轮排序（个位，exp-1）"><a href="#第1轮排序（个位，exp-1）" class="headerlink" title="第1轮排序（个位，exp &#x3D; 1）"></a>第1轮排序（个位，exp &#x3D; 1）</h3><p><strong>排序代码调用：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">countingSort</span>(arr, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>执行过程：</strong></p>
<ol>
<li><p><strong>初始化计数数组和输出数组：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">output = [0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>统计每个数在个位上的出现次数：</strong></p>
<ul>
<li>170 → 0</li>
<li>45  → 5</li>
<li>75  → 5</li>
<li>90  → 0</li>
<li>802 → 2</li>
<li>24  → 4</li>
<li>2   → 2</li>
<li>66  → 6</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = [2, 0, 2, 0, 1, 2, 1, 0, 0, 0]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改计数数组，累加前面的计数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = [2, 2, 4, 4, 5, 7, 8, 8, 8, 8]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构建输出数组，从后向前遍历原数组：</strong></p>
<ul>
<li>66 → digit&#x3D;6 → position&#x3D;7 → output[7] &#x3D; 66 → count[6]&#x3D;7</li>
<li>2  → digit&#x3D;2 → position&#x3D;3 → output[3] &#x3D; 2 → count[2]&#x3D;3</li>
<li>24 → digit&#x3D;4 → position&#x3D;4 → output[4] &#x3D; 24 → count[4]&#x3D;4</li>
<li>802 → digit&#x3D;2 → position&#x3D;2 → output[2] &#x3D; 802 → count[2]&#x3D;2</li>
<li>90 → digit&#x3D;0 → position&#x3D;1 → output[1] &#x3D; 90 → count[0]&#x3D;1</li>
<li>75 → digit&#x3D;5 → position&#x3D;6 → output[6] &#x3D; 75 → count[5]&#x3D;6</li>
<li>45 → digit&#x3D;5 → position&#x3D;5 → output[5] &#x3D; 45 → count[5]&#x3D;5</li>
<li>170 → digit&#x3D;0 → position&#x3D;0 → output[0] &#x3D; 170 → count[0]&#x3D;0</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output = [170, 90, 802, 2, 24, 45, 75, 66]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将输出数组复制回原数组：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = [170, 90, 802, 2, 24, 45, 75, 66]</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>排序后数组：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排序后数组: 170 90 802 2 24 45 75 66 </span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<h3 id="第2轮排序（十位，exp-10）"><a href="#第2轮排序（十位，exp-10）" class="headerlink" title="第2轮排序（十位，exp &#x3D; 10）"></a>第2轮排序（十位，exp &#x3D; 10）</h3><p><strong>排序代码调用：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">countingSort</span>(arr, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>执行过程：</strong></p>
<ol>
<li><p><strong>初始化计数数组和输出数组：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">output = [0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>统计每个数在十位上的出现次数：</strong></p>
<ul>
<li>170 → 7</li>
<li>90  → 9</li>
<li>802 → 0</li>
<li>2   → 0</li>
<li>24  → 2</li>
<li>45  → 4</li>
<li>75  → 7</li>
<li>66  → 6</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = [2, 0, 1, 0, 1, 0, 1, 2, 0, 1]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改计数数组，累加前面的计数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = [2, 2, 3, 3, 4, 4, 5, 7, 7, 8]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构建输出数组，从后向前遍历原数组：</strong></p>
<ul>
<li>66 → digit&#x3D;6 → position&#x3D;4 → output[4] &#x3D; 66 → count[6]&#x3D;6</li>
<li>75 → digit&#x3D;7 → position&#x3D;6 → output[6] &#x3D; 75 → count[7]&#x3D;6</li>
<li>45 → digit&#x3D;4 → position&#x3D;3 → output[3] &#x3D; 45 → count[4]&#x3D;3</li>
<li>24 → digit&#x3D;2 → position&#x3D;2 → output[2] &#x3D; 24 → count[2]&#x3D;2</li>
<li>2  → digit&#x3D;0 → position&#x3D;1 → output[1] &#x3D; 2 → count[0]&#x3D;1</li>
<li>802 → digit&#x3D;0 → position&#x3D;0 → output[0] &#x3D; 802 → count[0]&#x3D;-0</li>
<li>90 → digit&#x3D;9 → position&#x3D;7 → output[7] &#x3D; 90 → count[9]&#x3D;7</li>
<li>170 → digit&#x3D;7 → position&#x3D;5 → output[5] &#x3D; 170 → count[7]&#x3D;5</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output = [802, 2, 24, 45, 66, 170, 75, 90]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将输出数组复制回原数组：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = [802, 2, 24, 45, 66, 170, 75, 90]</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>排序后数组：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排序后数组: 802 2 24 45 66 170 75 90 </span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<h3 id="第3轮排序（百位，exp-100）"><a href="#第3轮排序（百位，exp-100）" class="headerlink" title="第3轮排序（百位，exp &#x3D; 100）"></a>第3轮排序（百位，exp &#x3D; 100）</h3><p><strong>排序代码调用：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">countingSort</span>(arr, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><strong>执行过程：</strong></p>
<ol>
<li><p><strong>初始化计数数组和输出数组：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">output = [0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>统计每个数在百位上的出现次数：</strong></p>
<ul>
<li>802 → 8</li>
<li>2   → 0</li>
<li>24  → 0</li>
<li>45  → 0</li>
<li>66  → 0</li>
<li>170 → 1</li>
<li>75  → 0</li>
<li>90  → 0</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = [6, 1, 0, 0, 0, 0, 0, 0, 1, 0]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改计数数组，累加前面的计数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = [6, 7, 7, 7, 7, 7, 7, 7, 8, 8]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构建输出数组，从后向前遍历原数组：</strong></p>
<ul>
<li>90  → digit&#x3D;0 → position&#x3D;5 → output[5] &#x3D; 90 → count[0]&#x3D;5</li>
<li>75  → digit&#x3D;0 → position&#x3D;4 → output[4] &#x3D; 75 → count[0]&#x3D;4</li>
<li>170 → digit&#x3D;1 → position&#x3D;6 → output[6] &#x3D; 170 → count[1]&#x3D;6</li>
<li>66  → digit&#x3D;0 → position&#x3D;3 → output[3] &#x3D; 66 → count[0]&#x3D;3</li>
<li>45  → digit&#x3D;0 → position&#x3D;2 → output[2] &#x3D; 45 → count[0]&#x3D;2</li>
<li>24  → digit&#x3D;0 → position&#x3D;1 → output[1] &#x3D; 24 → count[0]&#x3D;1</li>
<li>2   → digit&#x3D;0 → position&#x3D;0 → output[0] &#x3D; 2 → count[0]&#x3D;0</li>
<li>802 → digit&#x3D;8 → position&#x3D;7 → output[7] &#x3D; 802 → count[8]&#x3D;7</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output = [2, 24, 45, 66, 75, 90, 170, 802]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将输出数组复制回原数组：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = [2, 24, 45, 66, 75, 90, 170, 802]</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>排序后数组：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排序后数组: 2 24 45 66 75 90 170 802 </span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<h3 id="排序过程总结-5"><a href="#排序过程总结-5" class="headerlink" title="排序过程总结"></a>排序过程总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">原始数组: 170 45 75 90 802 24 2 66 </span><br><span class="line">排序过程:</span><br><span class="line">按位排序，当前位数的权重(exp): 1</span><br><span class="line">排序后数组: 170 90 802 2 24 45 75 66 </span><br><span class="line">-----------------------------</span><br><span class="line">按位排序，当前位数的权重(exp): 10</span><br><span class="line">排序后数组: 802 2 24 45 66 170 75 90 </span><br><span class="line">-----------------------------</span><br><span class="line">按位排序，当前位数的权重(exp): 100</span><br><span class="line">排序后数组: 2 24 45 66 75 90 170 802 </span><br><span class="line">-----------------------------</span><br><span class="line">排序后数组: 2 24 45 66 75 90 170 802 </span><br></pre></td></tr></table></figure>

<h2 id="最终排序结果-6"><a href="#最终排序结果-6" class="headerlink" title="最终排序结果"></a>最终排序结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排序后数组: 2 24 45 66 75 90 170 802 </span><br></pre></td></tr></table></figure>

<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>基数排序（Radix Sort）通过<strong>分治</strong>策略，将排序过程分解为多个按位排序的子过程，通常使用计数排序（Counting Sort）作为稳定的子排序算法。其主要特点包括：</p>
<ul>
<li><strong>时间复杂度：</strong> O(d*(n + k))，其中d是数字的位数，n是元素数量，k是基数（通常为10）。</li>
<li><strong>空间复杂度：</strong> O(n + k)，需要额外的空间来存储临时数组。</li>
<li><strong>稳定性：</strong> 归并排序是稳定的排序算法，保持相同元素的相对顺序。</li>
<li><strong>适用性：</strong> 适用于处理大量的整数或可以映射为整数的键，尤其在位数较少时表现出色。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>对于位数较少且基数较小的情况下，表现出色。</li>
<li>是一种稳定的排序算法。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>需要额外的空间来存储临时数组。</li>
<li>对于位数较多或基数较大的数据，效率可能降低。</li>
</ul>
<p>通过上述示例，可以清晰地理解基数排序的工作机制，包括按位排序的过程、计数排序的应用及最终的有序结果。基数排序因其稳定性和较高的效率，在实际应用中，如大规模数据处理、数字排序等领域，具有重要的价值。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>LionLpeoridae</span>
                    </p>
                
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>狮兔</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"># 数据结构</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2024/12/21/Python%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">Python之异常处理</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© LionLpeoridae | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>